Accessing Hardware,Hardware Proxy,"If every client accesses a hardware device directly, problems due to hardware changes are exacerbated. If the bit encoding, memory address, or connection technology changes, then every client must be tracked down and modified. By providing a proxy to sit between the clients and the actual hardware, the impact of hardware changes is greatly limited, easing such modifications. For easiest maintenance, the clients should be unaware of bit encoding, encryption, and compression used by the device; these details should be managed by the Hardware Proxy with internal private functions",Newnes,Douglass
Accessing Hardware,Hardware Adapter,"While hardware that performs similar functions tend to have similar interfaces, often the information they need and the set of services differ. Rather than rewrite the clients of the hardware device to use the provided interface, an adapter is created that provides the expected interface to the clients while converting the requests to and from the actual hardware interface. The Hardware Adapter Pattern is useful when you have hardware that meets the semantic need of the system but that has an incompatible interface. The goal of the pattern is to minimize the reworking of code when one hardware design or implementation is replaced with another.",Newnes,Douglass
Accessing Hardware,Mediator,"Many embedded applications control sets of actuators that must work in concert to achieve the desired effect. For example, to achieve a coordinated movement of a multi-joint robot arm, all the motors must work together to provide the desired arm movement. Similarly, using reaction wheels or thrusters in a spacecraft in three dimensions requires many different such devices acting at precisely the right time and with the right amount of force to achieve attitude stabilization.",Newnes,Douglass
Accessing Hardware,Observer,"In a na√Øve situation, each client can request data periodically from a data server in case the data have changed, but that is wasteful of compute and communication resources as the clients generally cannot know when new data are available. If the data server pushes the data out, then it must know who all of its clients are, breaking the basic rule of client-server relations requiring changes to the server to add new clients. The Observer Pattern addresses this concern by adding subscription and unsubscription services to the data server. Thus a client can dynamically add itself to the notification list without a priori knowledge of the client on the part of the server. On the server side, the server can enforce the appropriate update policy to the notification of its interested clients. In addition, the pattern allows dynamic modification of subscriber lists and so adds a great deal of flexibility to the software.",Newnes,Douglass
Accessing Hardware,Debouncing,"Many input devices for embedded systems use metal-on-metal contact to indicate events of interest, such as button presses, switch movement, and activating or deactivating relays. As the metal moves into contact, physical deformation occurs resulting in an intermittent bouncing contact until the vibrations dampen down. This results in an intermediate contact profile such as that shown in Figure 3-10.",Newnes,Douglass
Accessing Hardware,Interrupt,"In many systems, events have different levels of urgency. Most embedded systems have at least some events with a high urgency that must be handled even when the system is busy doing other processing. The Polling Pattern, discussed elsewhere in this chapter, looks for events of interest when it is convenient for the system. While this has the advantage that primary processing can proceed uninterrupted, it has the disadvantage that high urgency and high
frequency events may not be handled in a timely fashion, or may be missed altogether. The
Interrupt Pattern addresses this problem by immediately pausing the current processing,
handling the incoming event, and then returning to the original computation.",Newnes,Douglass
Accessing Hardware,Polling,The Polling Pattern addresses the concern of getting new sensor data or hardware signals into the system as it runs when the data or events are not highly urgent and the time between data sampling can be guaranteed to be fast enough.,Newnes,Douglass
Embedding Concurrency and Resource Management,Cyclic Executive,Many embedded systems are tiny applications that have extremely tight memory and time constraints and cannot possibly host even a scaled-down microkernel RTOS. The Cyclic Executive Pattern provides a low-resource means to accomplish this goal.,Newnes,Douglass
Embedding Concurrency and Resource Management,Static Priority,The Static Priority Pattern provides a simple approach to scheduling tasks based on priority. This pattern addresses systems with more tasks than the Cyclic Executive Pattern and also emphasizes responsiveness to urgent events over fairness.,Newnes,Douglass
Embedding Concurrency and Resource Management,Critical Region,"There are two primary circumstances under which a task should not be interrupted or preempted. First, it may be accessing a resource that may not be safely accessed by multiple clients simultaneously. Secondly, the task may be performing actions that must be completed within a short period of time or that must be performed in a specific order. This pattern allows the active task to execute without any potential interference from other tasks.",Newnes,Douglass
Embedding Concurrency and Resource Management,Guarded Call,"The problem this pattern addresses is the need for a timely synchronization or data exchange between threads. In such cases, it may not be possible to wait for an asynchronous (queuing) rendezvous. A synchronous (function call) rendezvous can be made more timely, but this must be done carefully to avoid data corruption and erroneous computation.",Newnes,Douglass
Embedding Concurrency and Resource Management,Queuing,"In multithreaded systems, tasks must synchronize and share information with others. Two primary things must be accomplished. First, the tasks must synchronize to permit sharing of the information. Secondly, the information must be shared in such a way that there is no chance of corruption or race conditions. This pattern addresses such task interaction.",Newnes,Douglass
Embedding Concurrency and Resource Management,Rendezvous,The Rendezvous Pattern solves the problems when a set of tasks must synchronize in a complex fashion.,Newnes,Douglass
Embedding Concurrency and Resource Management,Simultaneous Locking,"The problem of deadlock is a serious enough one in highly reliable computing that many systems design in specific mechanisms to detect it or avoid it. As previously discussed, deadlock occurs when a task is waiting on a condition that can never, in principle, be satisfied. There are four conditions that must be true for deadlock to occur, and it is sufficient to deny the allowing any task to lock resources while waiting for other resources to be free.",Newnes,Douglass
Embedding Concurrency and Resource Management,Ordered Locking,"The Ordered Locking Pattern solely addresses the problem of deadlock elimination, as does the previous Simultaneous Locking Pattern.",Newnes,Douglass
State Machines,Single Event Receptor,This pattern addresses the problem of providing simple implementation of a state machine that applies to both synchronous and asynchronous event delivery.,Newnes,Douglass
State Machines,Multiple Event Receptor,This pattern addresses the problem of providing a simple robust implementation for synchronous state machines.,Newnes,Douglass
State Machines,State Table,"The problem addressed by the State Table Pattern is to implement a state machine for potentially large state spaces that are flat or can easily be made so. Also, this pattern is applicable when you want the performance of the state machine, in terms of the response time to a given event, independent of the size of the state space but you are unconcerned about the time necessary to initialize the state machine.",Newnes,Douglass
State Machines,State,"This pattern provides a means for implementing state machines that simplifies the stateful class by creating a set of objects, each of which implements the behavior of a single state. It makes the states explicit, rather easy to modify, and enables the extension of the state space by adding new state objects as needed.",Newnes,Douglass
State Machines,Decomposed AND-State,This pattern addresses the problem of implementing state machines that contain orthogonal regions (AND-states) in a way that preserves the AND-state design.,Newnes,Douglass
Safety and Reliability,One's Complement,"This pattern addresses the problem that variables may be corrupted by a variety of causes such as environmental factors (e.g., EMI, heat, radiation), hardware faults (e.g., power fluctuation, memory cell faults, address line shorts), or software faults (other software erroneously modifying memory). This pattern addresses the problem of identifying data corruption for small sets of critical data values.",Newnes,Douglass
Safety and Reliability,CRC,"This pattern addresses the problem that variables may be corrupted by a variety of causes such as environmental factors (e.g., EMI, heat, radiation), hardware faults (e.g., power fluctuation, memory cell faults, address line shorts), or software faults (other software erroneously modifying memory). This pattern addresses the problem of identifying data corruption for small sets of critical data values.",Newnes,Douglass
Safety and Reliability,Smart Data,"The most common idiom for error checking of data ranges in C is for functions that have no other return value: return a 0 value for function success and a -1 value for failure and set errno to an error code. The problem is, of course, that the most common way to ‚Äúhandle‚Äù the return values is to ignore them, resulting in difficult-to-debug systems. Some people even put error checking into the system during development but remove such checks in the final release. I would argue that the time when you really want to know that the altitude determination program in your aircraft isn't producing the right value is when you are in the flying aircraft. The problem this pattern addresses is to build functions and data types that essentially check themselves and provide error detection means that cannot be easily ignored.",Newnes,Douglass
Safety and Reliability,Channel,This pattern provides a basic element of large-scale redundancy that can be used in different ways to address safety and reliability concerns.,Newnes,Douglass
Safety and Reliability,Protected Single Channel,"Redundancy is expensive, not only in terms of development effort but also in terms of replicated hardware. In some cases, fully redundant channels may not be necessary. For example, if there is a fault-safe state (a state known to always be safe), the system must only be able to detect a fault and enter that state. This lowers the reliability of the system, but it may still meet the user needs.",Newnes,Douglass
Safety and Reliability,Dual Channel,"This pattern provides protection against single-point faults (either failures or both failures and
errors, depending on the specific subpattern selected). Depending on which pattern, the system
may detect a fault in one channel by comparing it to the other and then transition to the faultsafe
state OR it may use other means to detect the fault in one channel and switch to the other
when a fault occurs.",Newnes,Douglass