Behavioral,Visitor,Imagine that your team develops an app which works with geographic information structured as one colossal graph. Each node of the graph may represent a complex entity such as a city but also more granular things like industries sightseeing areas etc. The nodes are connected with others if there's a road between the real objects that they represent. Under the hood each node type is represented by its own class while each specific node is an object.At some point you got a task to implement exporting the graph into XML format. At first the job seemed pretty straightforward. You planned to add an export method to each node class and then leverage recursion to go over each node of the graph executing the export method. The solution was simple and elegant: thanks to polymorphism you weren't coupling the code which called the export method to concrete classes of nodes.Unfortunately the system architect refused to allow you to alter existing node classes. He said that the code was already in production and he didn't want to risk breaking it because of a potential bug in your changes.Besides he questioned whether it makes sense to have the XML export code within the node classes. The primary job of these classes was to work with geodata. The XML export behavior would look alien there.There was another reason for the refusal. It was highly likely that after this feature was implemented someone from the marketing department would ask you to provide the ability to export into a different format or request some other weird stuff. This would force you to change those precious and fragile classes again.,Refactoring,GOF
Behavioral,Command,Imagine that you're working on a new text-editor app. Your current task is to create a toolbar with a bunch of buttons for various operations of the editor. You created a very neat Button class that can be used for buttons on the toolbar as well as for generic buttons in various dialogs.While all of these buttons look similar they're all supposed to do different things. Where would you put the code for the various click handlers of these buttons? The simplest solution is to create tons of subclasses for each place where the button is used. These subclasses would contain the code that would have to be executed on a button click.Before long you realize that this approach is deeply flawed. First you have an enormous number of subclasses and that would be okay if you weren't risking breaking the code in these subclasses each time you modify the base Button class. Put simply your GUI code has become awkwardly dependent on the volatile code of the business logic.And here's the ugliest part. Some operations such as copying/pasting text would need to be invoked from multiple places. For example a user could click a small “Copy” button on the toolbar or copy something via the context menu or just hit Ctrl+C on the keyboard.Initially when our app only had the toolbar it was okay to place the implementation of various operations into the button subclasses. In other words having the code for copying text inside the CopyButton subclass was fine. But then when you implement context menus shortcuts and other stuff you have to either duplicate the operation's code in many classes or make menus dependent on buttons which is an even worse option.,Refactoring,GOF
Behavioral,Template Method,Imagine that you're creating a data mining application that analyzes corporate documents. Users feed the app documents in various formats (PDF DOC CSV) and it tries to extract meaningful data from these docs in a uniform format.The first version of the app could work only with DOC files. In the following version it was able to support CSV files. A month later you “taught” it to extract data from PDF files.At some point you noticed that all three classes have a lot of similar code. While the code for dealing with various data formats was entirely different in all classes the code for data processing and analysis is almost identical. Wouldn't it be great to get rid of the code duplication leaving the algorithm structure intact?There was another problem related to client code that used these classes. It had lots of conditionals that picked a proper course of action depending on the class of the processing object. If all three processing classes had a common interface or a base class you'd be able to eliminate the conditionals in client code and use polymorphism when calling methods on a processing object.,Refactoring,GOF
Behavioral,Mediator,Say you have a dialog for creating and editing customer profiles. It consists of various form controls such as text fields checkboxes buttons etc.Some of the form elements may interact with others. For instance selecting the “I have a dog” checkbox may reveal a hidden text field for entering the dog's name. Another example is the submit button that has to validate values of all fields before saving the data.By having this logic implemented directly inside the code of the form elements you make these elements' classes much harder to reuse in other forms of the app. For example you won't be able to use that checkbox class inside another form because it's coupled to the dog's text field. You can use either all the classes involved in rendering the profile form or none at all.,Refactoring,GOF
Behavioral,Strategy,One day you decided to create a navigation app for casual travelers. The app was centered around a beautiful map which helped users quickly orient themselves in any city.One of the most requested features for the app was automatic route planning. A user should be able to enter an address and see the fastest route to that destination displayed on the map.The first version of the app could only build the routes over roads. People who traveled by car were bursting with joy. But apparently not everybody likes to drive on their vacation. So with the next update you added an option to build walking routes. Right after that you added another option to let people use public transport in their routes.However that was only the beginning. Later you planned to add route building for cyclists. And even later another option for building routes through all of a city's tourist attractions.While from a business perspective the app was a success the technical part caused you many headaches. Each time you added a new routing algorithm the main class of the navigator doubled in size. At some point the beast became too hard to maintain.Any change to one of the algorithms whether it was a simple bug fix or a slight adjustment of the street score affected the whole class increasing the chance of creating an error in already-working code.In addition teamwork became inefficient. Your teammates who had been hired right after the successful release complain that they spend too much time resolving merge conflicts. Implementing a new feature requires you to change the same huge class conflicting with the code produced by other people.,Refactoring,GOF
Behavioral,Iterator,Collections are one of the most used data types in programming. Nonetheless a collection is just a container for a group of objects.Most collections store their elements in simple lists. However some of them are based on stacks trees graphs and other complex data structures.But no matter how a collection is structured it must provide some way of accessing its elements so that other code can use these elements. There should be a way to go through each element of the collection without accessing the same elements over and over.This may sound like an easy job if you have a collection based on a list. You just loop over all of the elements. But how do you sequentially traverse elements of a complex data structure such as a tree? For example one day you might be just fine with depth-first traversal of a tree. Yet the next day you might require breadth-first traversal. And the next week you might need something else like random access to the tree elements.Adding more and more traversal algorithms to the collection gradually blurs its primary responsibility which is efficient data storage. Additionally some algorithms might be tailored for a specific application so including them into a generic collection class would be weird.On the other hand the client code that's supposed to work with various collections may not even care how they store their elements. However since collections all provide different ways of accessing their elements you have no option other than to couple your code to the specific collection classes.,Refactoring,GOF
Behavioral,State,The State pattern is closely related to the concept of a Finite-State Machine Finite-State Machine: https://refactoring.guru/fsm.The main idea is that at any given moment there's a finite number of states which a program can be in. Within any unique state the program behaves differently and the program can be switched from one state to another instantaneously. However depending on a current state the program may or may not switch to certain other states. These switching rules called transitions are also finite and predetermined.You can also apply this approach to objects. Imagine that we have a Document class. A document can be in one of three states: Draft Moderation and Published. The publish method of the document works a little bit differently in each state:State machines are usually implemented with lots of conditional statements (if or switch) that select the appropriate behavior depending on the current state of the object. Usually this “state” is just a set of values of the object's fields. Even if you've never heard about finite-state machines before you've probably implemented a state at least once. Does the following code structure ring a bell?The biggest weakness of a state machine based on conditionals reveals itself once we start adding more and more states and state-dependent behaviors to the Document class. Most methods will contain monstrous conditionals that pick the proper behavior of a method according to the current state. Code like this is very difficult to maintain because any change to the transition logic may require changing state conditionals in every method.The problem tends to get bigger as a project evolves. It's quite difficult to predict all possible states and transitions at the design stage. Hence a lean state machine built with a limited set of conditionals can grow into a bloated mess over time.,Refactoring,GOF
Behavioral,Memento,"Imagine that you're creating a text editor app. In addition to simple text editing your editor can format text insert inline images etc.At some point you decided to let users undo any operations carried out on the text. This feature has become so common over the years that nowadays people expect every app to have it. For the implementation you chose to take the direct approach. Before performing any operation the app records the state of all objects and saves it in some storage. Later when a user decides to revert an action the app fetches the latest snapshot from the history and uses it to restore the state of all objects.Let's think about those state snapshots. How exactly would you produce one? You'd probably need to go over all the fields in an object and copy their values into storage. However this would only work if the object had quite relaxed access restrictions to its contents. Unfortunately most real objects won't let others peek inside them that easily hiding all significant data in private fields.Ignore that problem for now and let's assume that our objects behave like hippies: preferring open relations and keeping their state public. While this approach would solve the immediate problem and let you produce snapshots of objects' states at will it still has some serious issues. In the future you might decide to refactor some of the editor classes or add or remove some of the fields. Sounds easy but this would also require changing the classes responsible for copying the state of the affected objects.But there's more. Let's consider the actual “snapshots” of the editor's state. What data does it contain? At a bare minimum it must contain the actual text cursor coordinates current scroll position etc. To make a snapshot you'd need to collect these values and put them into some kind of container.Most likely you're going to store lots of these container objects inside some list that would represent the history. Therefore the containers would probably end up being objects of one class. The class would have almost no methods but lots of fields that mirror the editor's state. To allow other objects to write and read data to and from a snapshot you'd probably need to make its fields public. That would expose all the editor's states private or not. Other classes would become dependent on every little change to the snapshot class which would otherwise happen within private fields and methods without affecting outer classes.It looks like we've reached a dead end: you either expose all internal details of classes making them too fragile or restrict access to their state making it impossible to produce snapshots. Is there any other way to implement the ""undo""?",Refactoring,GOF
Behavioral,Observer,Imagine that you have two types of objects: a Customer and a Store. The customer is very interested in a particular brand of product (say it's a new model of the iPhone) which should become available in the store very soon.The customer could visit the store every day and check product availability. But while the product is still en route most of these trips would be pointless.On the other hand the store could send tons of emails (which might be considered spam) to all customers each time a new product becomes available. This would save some customers from endless trips to the store. At the same time it'd upset other customers who aren't interested in new products.It looks like we've got a conflict. Either the customer wastes time checking product availability or the store wastes resources notifying the wrong customers.,Refactoring,GOF
Behavioral,Chain of Responsibility,Imagine that you're working on an online ordering system. You want to restrict access to the system so only authenticated users can create orders. Also users who have administrative permissions must have full access to all orders.After a bit of planning you realized that these checks must be performed sequentially. The application can attempt to authenticate a user to the system whenever it receives a request that contains the user's credentials. However if those credentials aren't correct and authentication fails there's no reason to proceed with any other checks.During the next few months you implemented several more of those sequential checks.The code of the checks which had already looked like a mess became more and more bloated as you added each new feature. Changing one check sometimes affected the others. Worst of all when you tried to reuse the checks to protect other components of the system you had to duplicate some of the code since those components required some of the checks but not all of them.The system became very hard to comprehend and expensive to maintain. You struggled with the code for a while until one day you decided to refactor the whole thing.,Refactoring,GOF
Structural,Proxy,Why would you want to control access to an object? Here is an example: you have a massive object that consumes a vast amount of system resources. You need it from time to time but not always.You could implement lazy initialization: create this object only when it's actually needed. All of the object's clients would need to execute some deferred initialization code. Unfortunately this would probably cause a lot of code duplication.In an ideal world we'd want to put this code directly into our object's class but that isn't always possible. For instance the class may be part of a closed 3rd-party library.,Refactoring,GOF
Structural,Decorator,Imagine that you're working on a notification library which lets other programs notify their users about important events.The initial version of the library was based on the Notifier class that had only a few fields a constructor and a single send method. The method could accept a message argument from a client and send the message to a list of emails that were passed to the notifier via its constructor. A third-party app which acted as a client was supposed to create and configure the notifier object once and then use it each time something important happened.At some point you realize that users of the library expect more than just email notifications. Many of them would like to receive an SMS about critical issues. Others would like to be notified on Facebook and of course the corporate users would love to get Slack notifications.How hard can that be? You extended the Notifier class and put the additional notification methods into new subclasses. Now the client was supposed to instantiate the desired notification class and use it for all further notifications.But then someone reasonably asked you “Why can't you use several notification types at once? If your house is on fire you'd probably want to be informed through every channel.”You tried to address that problem by creating special subclasses which combined several notification methods within one class. However it quickly became apparent that this approach would bloat the code immensely not only the library code but the client code as well.You have to find some other way to structure notifications classes so that their number won't accidentally break some Guinness record.,Refactoring,GOF
Creational,Prototype,Say you have an object and you want to create an exact copy of it. How would you do it? First you have to create a new object of the same class. Then you have to go through all the fields of the original object and copy their values over to the new object.Nice! But there's a catch. Not all objects can be copied that way because some of the object's fields may be private and not visible from outside of the object itself.There's one more problem with the direct approach. Since you have to know the object's class to create a duplicate your code becomes dependent on that class. If the extra dependency doesn't scare you there's another catch. Sometimes you only know the interface that the object follows but not its concrete class when for example a parameter in a method accepts any objects that follow some interface.,Refactoring,GOF
Structural,Flyweight,To have some fun after long working hours you decided to create a simple video game: players would be moving around a map and shooting each other. You chose to implement a realistic particle system and make it a distinctive feature of the game. Vast quantities of bullets missiles and shrapnel from explosions should fly all over the map and deliver a thrilling experience to the player.Upon its completion you pushed the last commit built the game and sent it to your friend for a test drive. Although the game was running flawlessly on your machine your friend wasn't able to play for long. On his computer the game kept crashing after a few minutes of gameplay. After spending several hours digging through debug logs you discovered that the game crashed because of an insufficient amount of RAM. It turned out that your friend's rig was much less powerful than your own computer and that's why the problem emerged so quickly on his machine.The actual problem was related to your particle system. Each particle such as a bullet a missile or a piece of shrapnel was represented by a separate object containing plenty of data. At some point when the carnage on a player's screen reached its climax newly created particles no longer fit into the remaining RAM so the program crashed.,Refactoring,GOF
Creational,Singleton,The Singleton pattern solves two problems at the same time violating the Single Responsibility Principle:Nowadays the Singleton pattern has become so popular that people may call something a singleton even if it solves just one of the listed problems.,Refactoring,GOF
Structural,Composite,Using the Composite pattern makes sense only when the core model of your app can be represented as a tree.For example imagine that you have two types of objects: Products and Boxes. A Box can contain several Products as well as a number of smaller Boxes. These little Boxes can also hold some Products or even smaller Boxes and so on.Say you decide to create an ordering system that uses these classes. Orders could contain simple products without any wrapping as well as boxes stuffed with products...and other boxes. How would you determine the total price of such an order?You could try the direct approach: unwrap all the boxes go over all the products and then calculate the total. That would be doable in the real world; but in a program it's not as simple as running a loop. You have to know the classes of Products and Boxes you're going through the nesting level of the boxes and other nasty details beforehand. All of this makes the direct approach either too awkward or even impossible.,Refactoring,GOF
Structural,Facade,Imagine that you must make your code work with a broad set of objects that belong to a sophisticated library or framework. Ordinarily you'd need to initialize all of those objects keep track of dependencies execute methods in the correct order and so on.As a result the business logic of your classes would become tightly coupled to the implementation details of 3rd-party classes making it hard to comprehend and maintain.,Refactoring,GOF
Structural,Bridge,Abstraction? Implementation? Sound scary? Stay calm and let's consider a simple example.Say you have a geometric Shape class with a pair of subclasses: Circle and Square. You want to extend this class hierarchy to incorporate colors so you plan to create Red and Blue shape subclasses. However since you already have two subclasses you'll need to create four class combinations such as BlueCircle and RedSquare.Adding new shape types and colors to the hierarchy will grow it exponentially. For example to add a triangle shape you'd need to introduce two subclasses one for each color. And after that adding a new color would require creating three subclasses one for each shape type. The further we go the worse it becomes.,Refactoring,GOF
Structural,Adapter,Imagine that you're creating a stock market monitoring app. The app downloads the stock data from multiple sources in XML format and then displays nice-looking charts and diagrams for the user.At some point you decide to improve the app by integrating a smart 3rd-party analytics library. But there's a catch: the analytics library only works with data in JSON format.You could change the library to work with XML. However this might break some existing code that relies on the library. And worse you might not have access to the library's source code in the first place making this approach impossible.,Refactoring,GOF
Creational,Builder,Imagine a complex object that requires laborious step-by-step initialization of many fields and nested objects. Such initialization code is usually buried inside a monstrous constructor with lots of parameters. Or even worse: scattered all over the client code.For example let's think about how to create a House object. To build a simple house you need to construct four walls and a floor install a door fit a pair of windows and build a roof. But what if you want a bigger brighter house with a backyard and other goodies (like a heating system plumbing and electrical wiring)?The simplest solution is to extend the base House class and create a set of subclasses to cover all combinations of the parameters. But eventually you'll end up with a considerable number of subclasses. Any new parameter such as the porch style will require growing this hierarchy even more.There's another approach that doesn't involve breeding subclasses. You can create a giant constructor right in the base House class with all possible parameters that control the house object. While this approach indeed eliminates the need for subclasses it creates another problem.In most cases most of the parameters will be unused making the constructor calls pretty ugly. For instance only a fraction of houses have swimming pools so the parameters related to swimming pools will be useless nine times out of ten.,Refactoring,GOF
Creational,Abstract Factory,Imagine that you're creating a furniture shop simulator. Your code consists of classes that represent:You need a way to create individual furniture objects so that they match other objects of the same family. Customers get quite mad when they receive non-matching furniture.Also you don't want to change existing code when adding new products or families of products to the program. Furniture vendors update their catalogs very often and you wouldn't want to change the core code each time it happens.,Refactoring,GOF
Creational,Factory Method,Imagine that you're creating a logistics management application. The first version of your app can only handle transportation by trucks so the bulk of your code lives inside the Truck class.After a while your app becomes pretty popular. Each day you receive dozens of requests from sea transportation companies to incorporate sea logistics into the app.Great news right? But how about the code? At present most of your code is coupled to the Truck class. Adding Ships into the app would require making changes to the entire codebase. Moreover if later you decide to add another type of transportation to the app you will probably need to make all of these changes again.As a result you will end up with pretty nasty code riddled with conditionals that switch the app's behavior depending on the class of transportation objects.,Refactoring,GOF
Behavioral,Visitor,"Represent an operation to be performed on the elements of an object structure.  Visitor lets you define a new operation without changing the classes of the elements on which it operates.The classic technique for recovering lost type information.Do the right thing based on the type of two objects.Double dispatchMany distinct and unrelated operations need to be performed on node objects in a heterogeneous aggregate structure.  You want to avoid ""polluting"" the node classes with these operations.  And you don't want to have to query the type of each node and cast the pointer to the correct type before performing the desired operation.Visitor's primary purpose is to abstract functionality that can be applied to an aggregate hierarchy of ""element"" objects.  The approach encourages designing lightweight Element classes - because processing functionality is removed from their list of responsibilities.  New functionality can easily be added to the original inheritance hierarchy by creating a new Visitor subclass.Visitor implements ""double dispatch"".  OO messages routinely manifest ""single dispatch"" - the operation that is executed depends on: the name of the request and the type of the receiver.  In ""double dispatch"" the operation executed depends on:  the name of the request and the type of TWO receivers (the type of the Visitor and the type of the element it visits).The implementation proceeds as follows.  Create a Visitor class hierarchy that defines a pure virtual visit() method in the abstract base class for each concrete derived class in the aggregate node hierarchy.  Each visit() method accepts a single argument - a pointer or reference to an original Element derived class.Each operation to be supported is modelled with a concrete derived class of the Visitor hierarchy.  The visit() methods declared in the Visitor base class are now defined in each derived subclass by allocating the ""type query and cast"" code in the original implementation to the appropriate overloaded visit() method.Add a single pure virtual accept() method to the base class of the Element hierarchy.  accept() is defined to receive a single argument - a pointer or reference to the abstract base class of the Visitor hierarchy.Each concrete derived class of the Element hierarchy implements the accept() method by simply calling the visit() method on the concrete derived instance of the Visitor hierarchy that it was passed passing its ""this"" pointer as the sole argument.Everything for ""elements"" and ""visitors"" is now set-up.  When the client needs an operation to be performed (s)he creates an instance of the Visitor object calls the accept() method on each Element object and passes the Visitor object.The accept() method causes flow of control to find the correct Element subclass.  Then when the visit() method is invoked flow of control is vectored to the correct Visitor subclass. accept() dispatch plus visit() dispatch equals double dispatch.The Visitor pattern makes adding new operations (or utilities) easy - simply add a new Visitor derived class.  But if the subclasses in the aggregate node hierarchy are not stable keeping the Visitor subclasses in sync requires a prohibitive amount of effort.An acknowledged objection to the Visitor pattern is that is represents a regression to functional decomposition - separate the algorithms from the data structures.  While this is a legitimate interpretation perhaps a better perspective/rationale is the goal of promoting non-traditional behavior to full object status.",Sourcemaking,GOF
Behavioral,Template Method,"Define the skeleton of an algorithm in an operation deferring some steps to client subclasses.  Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm's structure.Base class declares algorithm 'placeholders' and derived classes implement the placeholders.Two different components have significant similarities but demonstrate no reuse of common interface or implementation.  If a change common to both components becomes necessary duplicate effort must be expended.The component designer decides which steps of an algorithm are invariant (or standard) and which are variant (or customizable).  The invariant steps are implemented in an abstract base class while the variant steps are either given a default implementation or no implementation at all.  The variant steps represent ""hooks"" or ""placeholders"" that can or must be supplied by the component's client in a concrete derived class.The component designer mandates the required steps of an algorithm and the ordering of the steps but allows the component client to extend or replace some number of these steps.Template Method is used prominently in frameworks.  Each framework implements the invariant pieces of a domain's architecture and defines ""placeholders"" for all necessary or interesting client customization options.  In so doing the framework becomes the ""center of the universe"" and the client customizations are simply ""the third rock from the sun"".  This inverted control structure has been affectionately labelled ""the Hollywood principle"" - ""don't call us we'll call you"".",Sourcemaking,GOF
Behavioral,Strategy,"Define a family of algorithms encapsulate each one and make them interchangeable. Strategy lets the algorithm vary independently from the clients that use it.Capture the abstraction in an interface bury implementation details in derived classes.One of the dominant strategies of object-oriented design is the ""open-closed principle"".Figure demonstrates how this is routinely achieved - encapsulate interface details in a base class and bury implementation details in derived classes.  Clients can then couple themselves to an interface and not have to experience the upheaval associated with change: no impact when the number of derived classes changes and no impact when the implementation of a derived class changes.  A generic value of the software community for years has been ""maximize cohesion and minimize coupling"".  The object-oriented design approach shown in figure is all about minimizing coupling.  Since the client is coupled only to an abstraction (i.e. a useful fiction) and not a particular realization of that abstraction the client could be said to be practicing ""abstract coupling"" . an object-oriented variant of the more generic exhortation ""minimize coupling"".A more popular characterization of this ""abstract coupling"" principle is ""Program to an interface not an implementation"".Clients should prefer the ""additional level of indirection"" that an interface (or an abstract base class) affords. The interface captures the abstraction (i.e. the ""useful fiction"") the client wants to exercise and the implementations of that interface are effectively hidden.",Sourcemaking,GOF
Behavioral,Iterator,"Provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation.The C++ and Java standard library abstraction that makes it possible to decouple collection classes and algorithms.Promote to ""full object status"" the traversal of a collection.Polymorphic traversalNeed to ""abstract"" the traversal of wildly different data structures so that algorithms can be defined that are capable of interfacing with each transparently.""An aggregate object such as a list should give you a way to access its elements without exposing its internal structure.  Moreover you might want to traverse the list in different ways depending on what you need to accomplish.  But you probably don't want to bloat the List interface with operations for different traversals even if you could anticipate the ones you'll require.  You might also need to have more than one traversal pending on the same list."" And providing a uniform interface for traversing many types of aggregate objects (i.e. polymorphic iteration) might be valuable.The Iterator pattern lets you do all this.  The key idea is to take the responsibility for access and traversal out of the aggregate object and put it into an Iterator object that defines a standard traversal protocol.The Iterator abstraction is fundamental to an emerging technology called ""generic programming"".  This strategy seeks to explicitly separate the notion of ""algorithm"" from that of ""data structure"".  The motivation is to: promote component-based development boost productivity and reduce configuration management.As an example if you wanted to support four data structures (array binary tree linked list and hash table) and three algorithms (sort find and merge) a traditional approach would require four times three permutations to develop and maintain.  Whereas a generic programming approach would only require four plus three configuration items.",Sourcemaking,GOF
Behavioral,Command,"Encapsulate a request as an object thereby letting you parametrize clients with different requests queue or log requests and support undoable operations.Promote ""invocation of a method on an object"" to full object statusAn object-oriented callbackNeed to issue requests to objects without knowing anything about the operation being requested or the receiver of the request.Command decouples the object that invokes the operation from the one that knows how to perform it.  To achieve this separation the designer creates an abstract base class that maps a receiver (an object) with an action (a pointer to a member function).  The base class contains an execute() method that simply calls the action on the receiver.All clients of Command objects treat each object as a ""black box"" by simply invoking the object's virtual execute() method whenever the client requires the object's ""service"".A Command class holds some subset of the following: an object a method to be applied to the object and the arguments to be passed when the method is applied.  The Command's ""execute"" method then causes the pieces to come together.Sequences of Command objects can be assembled into composite (or macro) commands.",Sourcemaking,GOF
Behavioral,Interpreter,"Given a language define a representation for its grammar along with an interpreter that uses the representation to interpret sentences in the language.Map a domain to a language the language to a grammar and the grammar to a hierarchical object-oriented design.A class of problems occurs repeatedly in a well-defined and well-understood domain.  If the domain were characterized with a ""language"" then problems could be easily solved with an interpretation ""engine"".The Interpreter pattern discusses: defining a domain language (i.e. problem characterization) as a simple language grammar representing domain rules as language sentences and interpreting these sentences to solve the problem.  The pattern uses a class to represent each grammar rule.  And since grammars are usually hierarchical in structure an inheritance hierarchy of rule classes maps nicely.An abstract base class specifies the method interpret().  Each concrete subclass implements interpret() by accepting (as an argument) the current state of the language stream and adding its contribution to the problem solving process.",Sourcemaking,GOF
Behavioral,Observer,"Define a one-to-many dependency between objects so that when one object changes state all its dependents are notified and updated automatically.Encapsulate the core (or common or engine) components in a Subject abstraction and the variable (or optional or user interface) components in an Observer hierarchy.The ""View"" part of Model-View-Controller.A large monolithic design does not scale well as new graphing or monitoring requirements are levied.Define an object that is the ""keeper"" of the data model and/or business logic (the Subject).  Delegate all ""view"" functionality to decoupled and distinct Observer objects.  Observers register themselves with the Subject as they are created.  Whenever the Subject changes it broadcasts to all registered Observers that it has changed and each Observer queries the Subject for that subset of the Subject's state that it is responsible for monitoring.This allows the number and ""type"" of ""view"" objects to be configured dynamically instead of being statically specified at compile-time.The protocol described above specifies a ""pull"" interaction model.  Instead of the Subject ""pushing"" what has changed to all Observers each Observer is responsible for ""pulling"" its particular ""window of interest"" from the Subject.  The ""push"" model compromises reuse while the ""pull"" model is less efficient.Issues that are discussed but left to the discretion of the designer include:  implementing event compression (only sending a single change broadcast after a series of consecutive changes has occurred) having a single Observer monitoring multiple Subjects and ensuring that a Subject notify its Observers when it is about to go away.The Observer pattern captures the lion's share of the Model-View-Controller architecture that has been a part of the Smalltalk community for years.",Sourcemaking,GOF
Behavioral,Memento,"Without violating encapsulation capture and externalize an object's internal state so that the object can be returned to this state later.A magic cookie that encapsulates a ""check point"" capability. Promote undo or rollback to full object status.Need to restore an object back to its previous state (e.g. ""undo"" or ""rollback"" operations).The client requests a Memento from the source object when it needs to checkpoint the source object's state.  The source object initializes the Memento with a characterization of its state.  The client is the ""care-taker"" of the Memento but only the source object can store and retrieve information from the Memento (the Memento is ""opaque"" to the client and all other objects).  If the client subsequently needs to ""rollback"" the source object's state it hands the Memento back to the source object for reinstatement.An unlimited ""undo"" and ""redo"" capability can be readily implemented with a stack of Command objects and a stack of Memento objects.The Memento design pattern defines three distinct roles: ",Sourcemaking,GOF
Behavioral,Mediator,"Define an object that encapsulates how a set of objects interact. Mediator promotes loose coupling by keeping objects from referring to each other explicitly and it lets you vary their interaction independently.Design an intermediary to decouple many peers.Promote the many-to-many relationships between interacting peers to ""full object status"".We want to design reusable components but dependencies between the potentially reusable pieces demonstrates the ""spaghetti code"" phenomenon (trying to scoop a single serving results in an ""all or nothing clump"").In Unix permission to access system resources is managed at three levels of granularity: world group and owner.  A group is a collection of users intended to model some functional affiliation.  Each user on the system can be a member of one or more groups and each group can have zero or more users assigned to it. Next figure shows three users that are assigned to all three groups.  If we were to model this in software we could decide to have User objects coupled to Group objects and Group objects coupled to User objects.  Then when changes occur both classes and all their instances would be affected.An alternate approach would be to introduce ""an additional level of indirection"" - take the mapping of users to groups and groups to users and make it an abstraction unto itself.  This offers several advantages: Users and Groups are decoupled from one another many mappings can easily be maintained and manipulated simultaneously and the mapping abstraction can be extended in the future by defining derived classes.  Partitioning a system into many objects generally enhances reusability but proliferating interconnections between those objects tend to reduce it again.  The mediator object: encapsulates all interconnections acts as the hub of communication is responsible for controlling and coordinating the interactions of its clients and promotes loose coupling by keeping objects from referring to each other explicitly.The Mediator pattern promotes a ""many-to-many relationship network"" to ""full object status"".  Modelling the inter-relationships with an object enhances encapsulation and allows the behavior of those inter-relationships to be modified or extended through subclassing.An example where Mediator is useful is the design of a user and group capability in an operating system.  A group can have zero or more users and a  user can be a member of zero or more groups.  The Mediator pattern provides a flexible and non-invasive way to associate and manage users and groups.",Sourcemaking,GOF
Behavioral,Null Object,"The intent of a Null Object is to encapsulate the absence of an object by providing a substitutable alternative that offers suitable default do nothing behavior. In short a design where ""nothing will come of nothing""Use the Null Object pattern whenan object requires a collaborator. The Null Object pattern does not introduce this collaboration--it makes use of a collaboration that already existssome collaborator instances should do nothingyou want to abstract the handling of null away from the clientGiven that an object reference may be optionally null and that the result of a null check is to do nothing or use some default value how can the absence of an object — the presence of a null reference — be treated transparently?Sometimes a class that requires a collaborator does not need the collaborator to do anything. However the class wishes to treat a collaborator that does nothing the same way it treats one that actually provides behavior.Consider for example a simple screen saver which displays balls that move about the screen and have special color effects. This is easily achieved by creating a Ball class to represent the balls and using a Strategy pattern to control the ball's motion and another Strategy pattern to control the ball's color.It would then be trivial to write strategies for many different types of motion and color effects and create balls with any combination of those. However to start with you want to create the simplest strategies possible to make sure everything is working. And these strategies could also be useful later since you want as strategies as possible strategies.  Now the simplest strategy would be no strategy. That is do nothing don't move and don't change color. However the Strategy pattern requires the ball to have objects which implement the strategy interfaces. This is where the Null Object pattern becomes useful.Simply implement a NullMovementStrategy which doesn't move the ball and a NullColorStrategy which doesn't change the ball's color. Both of these can probably be implemented with essentially no code. All the methods in these classes do ""nothing"". They are perfect examples of the Null Object Pattern.The key to the Null Object pattern is an abstract class that defines the interface for all objects of this type. The Null Object is implemented as a subclass of this abstract class. Because it conforms to the abstract class' interface it can be used any place this type of object is needed. As compared to using a special ""null"" value which doesn't actually implement the abstract interface and which must constantly be checked for with special code in any object which uses the abstract interface.It is sometimes thought that Null Objects are over simple and ""stupid"" but in truth a Null Object always knows exactly what needs to be done without interacting with any other objects. So in truth it is very ""smart.""",Sourcemaking,GOF
Behavioral,Chain of Responsibility,"Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request.  Chain the receiving objects and pass the request along the chain until an object handles it.Launch-and-leave requests with a single processing pipeline that contains many possible handlers.An object-oriented linked list with recursive traversal.There is a potentially variable number of ""handler"" or ""processing element"" or ""node"" objects and a stream of requests that must be handled.  Need to efficiently process the requests without hard-wiring handler relationships and precedence or request-to-handler mappings.  Encapsulate the processing elements inside a ""pipeline"" abstraction; and have clients ""launch and leave"" their requests at the entrance to the pipeline.    The pattern chains the receiving objects together and then passes any request messages from object to object until it reaches an object capable of handling the message.  The number and type of handler objects isn't known a priori they can be configured dynamically.  The chaining mechanism uses recursive composition to allow an unlimited number of handlers to be linked.Chain of Responsibility simplifies object interconnections.  Instead of senders and receivers maintaining references to all candidate receivers each sender keeps a single reference to the head of the chain and each receiver keeps a single reference to its immediate successor in the chain.Make sure there exists a ""safety net"" to ""catch"" any requests which go unhandled.Do not use Chain of Responsibility when each request is only handled by one handler or when the client object knows which service object should handle the request.",Sourcemaking,GOF
Structural,Proxy,Provide a surrogate or placeholder for another object to control access to it.Use an extra level of indirection to support distributed controlled or intelligent access.Add a wrapper and delegation to protect the real component from undue complexity.You need to support resource-hungry objects and you do not want to instantiate such objects unless and until they are actually requested by the client.Design a surrogate or proxy object that: instantiates the real object the first time the client makes a request of the proxy remembers the identity of this real object and forwards the instigating request to this real object.  Then all subsequent requests are simply forwarded directly to the encapsulated real object.There are four common situations in which the Proxy pattern is applicable.Counting the number of references to the real object so that it can be freed automatically when there are no more references (aka smart pointer)Loading a persistent object into memory when it's first referencedChecking that the real object is locked before it is accessed to ensure that no other object can change it.,Sourcemaking,GOF
Structural,Flyweight,"Use sharing to support large numbers of fine-grained objects efficiently.The Motif GUI strategy of replacing heavy-weight widgets with light-weight gadgets.Designing objects down to the lowest levels of system ""granularity"" provides optimal flexibility but can be unacceptably expensive in terms of performance and memory usage.The Flyweight pattern describes how to share objects to allow their use at fine granularity without prohibitive cost.  Each ""flyweight"" object is divided into two pieces:  the state-dependent (extrinsic) part and the state-independent (intrinsic) part.  Intrinsic state is stored (shared) in the Flyweight object.  Extrinsic state is stored or computed by client objects and passed to the Flyweight when its operations are invoked.An illustration of this approach would be Motif widgets that have been re-engineered as light-weight gadgets.  Whereas widgets are ""intelligent"" enough to stand on their own; gadgets exist in a dependent relationship with their parent layout manager widget.  Each layout manager provides context-dependent event handling real estate management and resource services to its flyweight gadgets and each gadget is only responsible for context-independent state and behavior.",Sourcemaking,GOF
Structural,Decorator,"Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality.Client-specified embellishment of a core object by recursively wrapping it.Wrapping a gift putting it in a box and wrapping the box.You want to add behavior or state to individual objects at run-time. Inheritance is not feasible because it is static and applies to an entire class.Suppose you are working on a user interface toolkit and you wish to support adding borders and scroll bars to windows.  You could define an inheritance hierarchy like ...  But the Decorator pattern suggests giving the client the ability to specify whatever combination of ""features"" is desired.This flexibility can be achieved with the following design  Another example of cascading (or chaining) features together to produce a custom object might look like ...The solution to this class of problems involves encapsulating the original object inside an abstract  wrapper interface.  Both the decorator objects and the core object inherit from this abstract interface.  The interface uses recursive composition to allow an unlimited number of decorator ""layers"" to be added to each core object.Note that this pattern allows responsibilities to be added to an object not methods to an object's interface.  The interface presented to the client must remain constant as successive layers are specified.Also note that the core object's identity has now been ""hidden"" inside of a decorator object.  Trying to access the core object directly is now a problem.",Sourcemaking,GOF
Structural,Composite,"Compose objects into tree structures to represent whole-part hierarchies.  Composite lets clients treat individual objects and compositions of objects uniformly.Recursive composition""Directories contain entries each of which could be a directory.""1-to-many ""has a"" up the ""is a"" hierarchyApplication needs to manipulate a hierarchical collection of ""primitive"" and ""composite"" objects.  Processing of a primitive object is handled one way and processing of a composite object is handled differently. Having to query the ""type"" of each object before attempting to process it is not desirable.Define an abstract base class (Component) that specifies the behavior that needs to be exercised uniformly across all primitive and composite objects.  Subclass the Primitive and Composite classes off of the Component class.  Each Composite object ""couples"" itself only to the abstract type Component as it manages its ""children"".Use this pattern whenever you have ""composites that contain components each of which could be a composite"".Child management methods [e.g. addChild() removeChild()] should normally be defined in the Composite class.  Unfortunately the desire to treat Primitives and Composites uniformly requires that these methods be moved to the abstract Component class.  See the ""Opinions"" section below for a discussion of ""safety"" versus ""transparency"" issues.",Sourcemaking,GOF
Structural,Facade,"Provide a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use.Wrap a complicated subsystem with a simpler interface.A segment of the client community needs a simplified interface to the overall functionality of a complex subsystem.Facade discusses encapsulating a complex subsystem within a single interface object.  This reduces the learning curve necessary to successfully leverage the subsystem.  It also promotes decoupling the subsystem from its potentially many clients.  On the other hand if the Facade is the only access point for the subsystem it will limit the features and flexibility that ""power users"" may need.The Facade object should be a fairly simple advocate or facilitator.  It should not become an all-knowing oracle or ""god"" object.",Sourcemaking,GOF
Behavioral,State,"Allow an object to alter its behavior when its internal state changes. The object will appear to change its class.An object-oriented state machinewrapper + polymorphic wrappee + collaborationA monolithic object's behavior is a function of its state and it must change its behavior at run-time depending on that state.  Or an application is characterized by large and numerous case statements that vector flow of control based on the state of the application.The State pattern is a solution to the problem of how to make behavior depend on state.Define a ""context"" class to present a single interface to the outside world.Define a State abstract base class.Represent the different ""states"" of the state machine as derived classes of the State base class.Define state-specific behavior in the appropriate State derived classes.Maintain a pointer to the current ""state"" in the ""context"" class.To change the state of the state machine change the current ""state"" pointer.The State pattern does not specify where the state transitions will be defined.  The choices are two: the ""context"" object or each individual State derived class.  The advantage of the latter option is ease of adding new State derived classes.  The disadvantage is each State derived class has knowledge of (coupling to) its siblings which introduces dependencies between subclasses.A table-driven approach to designing finite state machines does a good job of specifying state transitions but it is difficult to add actions to accompany the state transitions.  The pattern-based approach uses code (instead of data structures) to specify state transitions but it does a good job of accommodating state transition actions.",Sourcemaking,GOF
Creational,Prototype,"Specify the kinds of objects to create using a prototypical instance and create new objects by copying this prototype.Co-opt one instance of a class for use as a breeder of all future instances.The new operator considered harmful.Application ""hard wires"" the class of object to create in each ""new"" expression.Declare an abstract base class that specifies a pure virtual ""clone"" method and maintains a dictionary of all ""cloneable"" concrete derived classes.  Any class that needs a ""polymorphic constructor"" capability: derives itself from the abstract base class registers its prototypical instance and implements the clone() operation.The client then instead of writing code that invokes the ""new"" operator on a hard-wired class name calls a ""clone"" operation on the abstract base class supplying a string or enumerated data type that designates the particular concrete derived class desired.",Sourcemaking,GOF
Structural,Bridge,"Decouple an abstraction from its implementation so that the two can vary independently.Publish interface in an inheritance hierarchy and bury implementation in its own inheritance hierarchy.Beyond encapsulation to insulation""Hardening of the software arteries"" has occurred by using subclassing of an abstract base class to provide alternative implementations.  This locks in compile-time binding between interface and implementation. The abstraction and implementation cannot be independently extended or composed.Consider the domain of ""thread scheduling"".  There are two types of thread schedulers and two types of operating systems or ""platforms"".  Given this approach to specialization we have to define a class for each permutation of these two dimensions. If we add a new platform (say ... Java's Virtual Machine) what would our hierarchy look like?  What if we had three kinds of thread schedulers and four kinds of platforms?  What if we had five kinds of thread schedulers and ten kinds of platforms?  The number of classes we would have to define is the product of the number of scheduling schemes and the number of platforms.The Bridge design pattern proposes refactoring this exponentially explosive inheritance hierarchy into two orthogonal hierarchies – one for platform-independent abstractions and the other for platform-dependent implementations.  Decompose the component's interface and implementation into orthogonal class hierarchies.  The interface class contains a pointer to the abstract implementation class.  This pointer is initialized with an instance of a concrete implementation class but all subsequent interaction from the interface class to the implementation class is limited to the abstraction maintained in the implementation base class.  The client interacts with the interface class and it in turn ""delegates"" all requests to the implementation class.The interface object is the ""handle"" known and used by the client; while the implementation object or ""body"" is safely encapsulated to ensure that it may continue to evolve or be entirely replaced (or shared at run-time.Use the Bridge pattern when:you want run-time binding of the implementationyou have a proliferation of classes resulting from a coupled interface and numerous implementationsyou want to share an implementation among multiple objectsyou need to map orthogonal class hierarchies.Consequences include:decoupling the object's interfaceimproved extensibility (you can extend (i.e. subclass) the abstraction and implementation hierarchies independently)hiding details from clients.Bridge is a synonym for the ""handle/body"" idiom.  This is a design mechanism that encapsulates an implementation class inside of an interface class.  The former is the body and the latter is the handle.  The handle is viewed by the user as the actual class but the work is done in the body. ""The handle/body class idiom may be used to decompose a complex abstraction into smaller more manageable classes.  The idiom may reflect the sharing of a single resource by multiple classes that control access to it (e.g. reference counting).""",Sourcemaking,GOF
Structural,Private Class Data,Control write access to class attributesSeparate data from methods that use itEncapsulate class data initializationProviding new type of final - final after constructorA class may expose its attributes (class variables) to manipulation when manipulation is no longer desirable e.g. after construction. Using the private class data design pattern prevents that undesirable manipulation.A class may have one-time mutable attributes that cannot be declared final. Using this design pattern allows one-time setting of those class attributes.The motivation for this design pattern comes from the design goal of protecting class state by minimizing the visibility of its attributes (data).The private class data design pattern seeks to reduce exposure of attributes by limiting their visibility.It reduces the number of class attributes by encapsulating them in single Data object. It allows the class designer to remove write privilege of attributes that are intended to be set only during construction even from methods of the target class.,Sourcemaking,GOF
Structural,Adapter,"Convert the interface of a class into another interface clients expect.  Adapter lets classes work together that couldn't otherwise because of incompatible interfaces.Wrap an existing class with a new interface.Impedance match an old component to a new systemAn ""off the shelf"" component offers compelling functionality that you would like to reuse but its ""view of the world"" is not compatible with the philosophy and architecture of the system currently being developed.Reuse has always been painful and elusive.  One reason has been the tribulation of designing something new while reusing something old. There is always something not quite right between the old and the new. It may be physical dimensions or misalignment.  It may be timing or synchronization.  It may be unfortunate assumptions or competing standards.It is like the problem of inserting a new three-prong electrical plug in an old two-prong wall outlet – some kind of adapter or intermediary is necessary.    Adapter is about creating an intermediary abstraction that translates or maps the old component to the new system.  Clients call methods on the Adapter object which redirects them into calls to the legacy component.  This strategy can be implemented either with inheritance or with aggregation.Adapter functions as a wrapper or modifier of an existing class.  It provides a different or translated view of that class.",Sourcemaking,GOF
Creational,Singleton,"Ensure a class has only one instance and provide a global point of access to it.Encapsulated ""just-in-time initialization"" or ""initialization on first use"".Application needs one and only one instance of an object.  Additionally lazy initialization and global access are necessary.Make the class of the single instance object responsible for creation initialization access and enforcement.  Declare the instance as a private static data member.  Provide a public static member function that encapsulates all initialization code and provides access to the instance.The client calls the accessor function (using the class name and scope resolution operator) whenever a reference to the single instance is required.Singleton should be considered only if all three of the following criteria are satisfied:Ownership of the single instance cannot be reasonably assignedLazy initialization is desirableGlobal access is not otherwise provided forIf ownership of the single instance when and how initialization occurs and global access are not issues Singleton is not sufficiently interesting.The Singleton pattern can be extended to support access to an application-specific number of instances.The ""static member function accessor"" approach will not support subclassing of the Singleton class.  If subclassing is desired refer to the discussion in the book.Deleting a Singleton class/instance is a non-trivial design problem.   See ""To Kill A Singleton"" by John Vlissides for a discussion.",Sourcemaking,GOF
Creational,Object Pool,"Object pooling can offer a significant performance boost; it is most effective in situations where the cost of initializing a class instance is high the rate of instantiation of a class is high and the number of instantiations in use at any one time is low. Object pools (otherwise known as resource pools) are used to manage the object caching. A client with access to a Object pool can avoid creating a new Objects by simply asking the pool for one that has already been instantiated instead. Generally the pool will be a growing pool i.e. the pool itself will create new objects if the pool is empty or we can have a pool which restricts the number of objects created.It is desirable to keep all Reusable objects that are not currently in use in the same object pool so that they can be managed by one coherent policy. To achieve this the Reusable Pool class is designed to be a singleton class.The Object Pool lets others ""check out"" objects from its pool when those objects are no longer needed by their processes they are returned to the pool in order to be reused. However we don't want a process to have to wait for a particular object to be released so the Object Pool also instantiates new objects as they are required but must also implement a facility to clean up unused objects periodically.",Sourcemaking,GOF
Creational,Factory Method,"Define an interface for creating an object but let subclasses decide which class to instantiate.  Factory Method lets a class defer instantiation to subclasses.Defining a ""virtual"" constructor.The new operator considered harmful.A framework needs to standardize the architectural model for a range of applications but allow for individual applications to define their own domain objects and provide for their instantiation.Factory Method is to creating objects as Template Method is to implementing an algorithm.  A superclass specifies all standard and generic behavior (using pure virtual ""placeholders"" for creation steps) and then delegates the creation details to subclasses that are supplied by the client.Factory Method makes a design more customizable and only a little more complicated.  Other design patterns require new classes whereas Factory Method only requires a new operation.People often use Factory Method as the standard way to create objects; but it isn't necessary if: the class that's instantiated never changes or instantiation takes place in an operation that subclasses can easily override (such as an initialization operation).Factory Method is similar to Abstract Factory but without the emphasis on families.Factory Methods are routinely specified by an architectural framework and then implemented by the user of the framework.",Sourcemaking,GOF
Creational,Builder,"Separate the construction of a complex object from its representation so that the same construction process can create different representations.Parse a complex representation create one of several targets.An application needs to create the elements of a complex aggregate. The specification for the aggregate exists on secondary storage and one of many representations needs to be built in primary storage.Separate the algorithm for interpreting (i.e. reading and parsing) a stored persistence mechanism (e.g. RTF files) from the algorithm for building and representing one of many target products (e.g. ASCII TeX text widget).  The focus/distinction is on creating complex aggregates.The ""director"" invokes ""builder"" services as it interprets the external format.  The ""builder"" creates part of the complex object each time it is called and maintains all intermediate state.  When the product is finished the client retrieves the result from the ""builder"".Affords finer control over the construction process.  Unlike creational patterns that construct products in one shot the Builder pattern constructs the product step by step under the control of the ""director"".",Sourcemaking,GOF
Creational,Abstract Factory,"Provide an interface for creating families of related or dependent objects without specifying their concrete classes.A hierarchy that encapsulates: many possible ""platforms"" and the construction of a suite of ""products"".The new operator considered harmful.If an application is to be portable it needs to encapsulate platform dependencies.  These ""platforms"" might include: windowing system operating system database etc.  Too often this encapsulation is not engineered in advance and lots of #ifdef case statements with options for all currently supported platforms begin to procreate like rabbits throughout the code.Provide a level of indirection that abstracts the creation of families of related or dependent objects without directly specifying their concrete classes.  The ""factory"" object has the responsibility for providing creation services for the entire platform family.  Clients never create platform objects directly they ask the factory to do that for them.This mechanism makes exchanging product families easy because the specific class of the factory object appears only once in the application - where it is instantiated.  The application can wholesale replace the entire family of products simply by instantiating a different concrete instance of the abstract factory.Because the service provided by the factory object is so pervasive it is routinely implemented as a Singleton.",Sourcemaking,GOF
