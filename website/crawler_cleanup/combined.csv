Singleton,"Object oriented code has a bad reputation for being cluttered. How can you avoid creating large numbers of unnecessary objects? How can you limit the number of instances of a class? And how can a class control its instantiation?Using a singleton pattern solves these problems. It’s a creational design pattern that describes how to define classes with only a single instance that will be accessed globally. To implement the singleton pattern, you should make the constructor of the main class private so that it is only accessible to members of the class and create a static method (getInstance) for object creation that acts as a constructor.Here’s the implementation of the singleton pattern in Python.The above code is the traditional way to implement the singleton pattern, but you can make it easier by using __new__ or creating a metaclass).You should use this design pattern only when you are 100% certain that your application requires only a single instance of the main class. Singleton pattern has several drawbacks compared to other design patterns:Check out some more drawbacks of using a singleton pattern.; A class of which only a single instance can exist; Singleton. Ensures only one instance of an object is created."
Decorator,"If you’re following SOLID principles (and in general, you should), you’ll want to create objects or entities that are open for extension but closed for modification. How can you extend the functionality of an object at run-time? How can you extend an object’s behavior without affecting the other existing objects?
You might consider using inheritance to extend the behavior of an existing object. However, inheritance is static. You can’t modify an object at runtime. Alternatively, you can use the decorator pattern to add additional functionality to objects (subclasses) at runtime without changing the parent class. The decorator pattern (also known as a wrapper) is a structural design pattern that lets you cover an existing class with multiple wrappers.For wrappers, it employs abstract classes or interfaces through composition (instead of inheritance). In composition, one object contains an instance of other classes that implement the desired functionality rather than inheriting from the parent class. Many design patterns, including the decorator, are based on the principle of composition. Check out why you should use composition over inheritance.The above code is the classic way of implementing the decorator pattern. You can also implement it using functions.The decorator pattern implements the single-responsibility principle. You can split large classes into several small classes, each implementing a specific behavior and extend them afterward. Wrapping the decorators with other decorators increases the complexity of code with multiple layers. Also, it is difficult to remove a specific wrapper from the wrappers' stack.; Add responsibilities to objects dynamically; Decorator. Allows for an object’s behavior to be extended dynamically at run time."
Strategy,"How can you change the algorithm at the run-time? You might tend to use conditional statements. But if you have many variants of algorithms, using conditionals makes our main class verbose. How can you refactor these algorithms to be less verbose?The strategy pattern allows you to change algorithms at runtime. You can avoid using conditional statements inside the main class and refactor the code into separate strategy classes. In the strategy pattern, you should define a family of algorithms, encapsulate each one and make them interchangeable at runtime.You can easily implement the strategy pattern by creating separate classes for algorithms. You can also implement different strategies as functions instead of using classes.Here’s a typical implementation of the strategy pattern:In the above code snippet, the client code is simple and straightforward. But in real-world application, the context changes depend on user actions, like when they click a button or change the level of the game. For example, in a chess application, the computer uses different strategy when you select the level of difficulty.It follows the single-responsibility principle as the massive content main (context) class is divided into different strategy classes. You can add as many additional strategies as you want while keeping the main class unchanged (open/closed principle). It increases the flexibility of our application. It would be best to use this pattern when your main class has many conditional statements that switch between different variants of the same algorithm. However, if your code contains only a few algorithms, there is no need to use a strategy pattern. It just makes your code look complicated with all of the classes and objects.; Encapsulates an algorithm inside a class; Strategy. Allows one of a family of algorithms to be selected on-the-fly at run-time."
State,"Object oriented programming in particular has to deal with the state that the application is currently in. How can you change an object’s behavior based on its internal state? What is the best way to define state-specific behavior?The state pattern is a behavioral design pattern. It provides an alternative approach to using massive conditional blocks for implementing state-dependent behavior in your main class. Your application behaves differently depending on its internal state, which a user can change at runtime. You can design finite state machines using the state pattern. In the state pattern, you should define separate classes for each state and add transitions between them.State pattern follows both the single-responsibility principle as well as the open/closed principle. You can add as many states and transitions as you want without changing the main class. The state pattern is very similar to the strategy pattern, but a strategy is unaware of other strategies, whereas a state is aware of other states and can switch between them. If your class (or state machine) has a few states or rarely changes, you should avoid using the state pattern.; Alter an object's behavior when its state changes; State. Allows an object to alter its behavior when its internal state changes."
Command,"The command pattern is a behavioral design pattern that encapsulates all the information about a request into a separate command object. Using the command pattern, you can store multiple commands in a class to use them over and over. It lets you parameterize methods with different requests, delay or queue a request’s execution, and support undoable operations. It increases the flexibility of your application.A command pattern implements the single-responsibility principle, as you have divided the request into separate classes such as invokers, commands, and receivers. It also follows the open/closed principle. You can add new command objects without changing the previous commands.Suppose you want to implement reversible operations (like undo/redo) using a command pattern. In that case, you should maintain a command history: a stack containing all executed command objects and the application’s state. It consumes a lot of RAM, and sometimes it is impossible to implement an efficient solution. You should use the command pattern if you have many commands to execute; otherwise, the code may become more complicated since you’re adding a separate layer of commands between senders and receivers.; Encapsulate a command request as an object; Command. Creates objects which encapsulate actions and parameters."
Abstract Factory,Creates an instance of several families of classes; Abstract Factory. Allows the creation of objects without specifying their concrete type.
Builder,Separates object construction from its representation; Builder. Uses to create complex objects.
Factory Method,Creates an instance of several derived classes; Factory Method. Creates objects without specifying the exact class to create.
Object Pool,Avoid expensive acquisition and release of resources by recycling objects that are no longer in use
Prototype,A fully initialized instance to be copied or cloned; Prototype. Creates a new object from an existing object.
Adapter,Match interfaces of different classes; Adapter. Allows for two incompatible classes to work together by wrapping an interface around one of the existing classes.
Bridge,Separates an object’s interface from its implementation; Bridge. Decouples an abstraction so two classes can vary independently.
Composite,A tree structure of simple and composite objects; Composite. Takes a group of objects into a single object.
Facade,A single class that represents an entire subsystem; Facade. Provides a simple interface to a more complex underlying object.
Flyweight,A fine-grained instance used for efficient sharing; Flyweight. Reduces the cost of complex object models.
Private Class Data,Restricts accessor/mutator access
Proxy,"An object representing another object; Proxy. Provides a placeholder interface to an underlying object to control access, reduce cost, or reduce complexity."
Chain of responsibility,A way of passing a request between a chain of objects
Interpreter,A way to include language elements in a program; Interpreter. Implements a specialized language.
Iterator,Sequentially access the elements of a collection; Iterator. Accesses the elements of an object sequentially without exposing its underlying representation.
Mediator,Defines simplified communication between classes; Mediator. Allows loose coupling between classes by being the only class that has detailed knowledge of their methods.
Memento,Capture and restore an object's internal state; Memento. Provides the ability to restore an object to its previous state.
Null Object,Designed to act as a default value of an object
Observer,A way of notifying change to a number of classes; Observer. Is a publish/subscribe pattern which allows a number of observer objects to see an event.
Template method,Defer the exact steps of an algorithm to a subclass
Visitor,Defines a new operation to a class without change; Visitor. Separates an algorithm from an object structure by moving the hierarchy of methods into one object.
Chain of Responsibility,Chain of Responsibility. Delegates commands to a chain of processing objects.
Template Method,"Template Method. Defines the skeleton of an algorithm as an abstract class, allowing its sub-classes to provide concrete behavior."
