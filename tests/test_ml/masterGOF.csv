Behavioral,Visitor,"Imagine that your team develops an app which works with geographic information structured as one colossal graph. Each node of the graph may represent a complex entity such as a city, but also more granular things like industries, sightseeing areas, etc. The nodes are connected with others if there's a road between the real objects that they represent. Under the hood, each node type is represented by its own class, while each specific node is an object .At some point, you got a task to implement exporting the graph into XML format. At first, the job seemed pretty straightforward. You planned to add an export method to each node class and then leverage recursion to go over each node of the graph, executing the export method. The solution was simple and elegant: thanks to polymorphism, you weren't coupling the code which called the export method to concrete classes of nodes. Unfortunately, the system architect refused to allow you to alter existing node classes. He said that the code was already in production and he didn't want to risk breaking it because of a potential bug in your changes. Besides, he questioned whether it makes sense to have the XML export code within the node classes. The primary job of these classes was to work with geodata. The XML export behavior would look alien there.There was another reason for the refusal. It was highly likely that after this feature was implemented, someone from the marketing department would ask you to provide the ability to export into a different format, or request some other weird stuff. This would force you to change those precious and fragile classes again."
Behavioral,Command,"Imagine that you're working on a new text-editor app. Your current task is to create a toolbar with a bunch of buttons for various operations of the editor. You created a very neat Button class that can be used for buttons on the toolbar, as well as for generic buttons in various dialogs. While all of these buttons look similar, they're all supposed to do different things. Where would you put the code for the various click handlers of these buttons? The simplest solution is to create tons of subclasses for each place where the button is used. These subclasses would contain the code that would have to be executed on a button click. Before long, you realize that this approach is deeply flawed. First, you have an enormous number of subclasses, and that would be okay if you weren't risking breaking the code in these subclasses each time you modify the base Button class. Put simply, your GUI code has become awkwardly dependent on the volatile code of the business logic. And here's the ugliest part. Some operations, such as copying/pasting text, would need to be invoked from multiple places. For example, a user could click a small Copy button on the toolbar, or copy something via the context menu, or just hit Ctrl+C on the keyboard. Initially, when our app only had the toolbar, it was okay to place the implementation of various operations into the button subclasses. In other words, having the code for copying text inside the CopyButton subclass was fine. But then, when you implement context menus, shortcuts, and other stuff, you have to either duplicate the operation's code in many classes or make menus dependent on buttons, which is an even worse option."
Behavioral,Strategy,"One day you decided to create a navigation app for casual travelers. The app was centered around a beautiful map which helped users quickly orient themselves in any city. One of the most requested features for the app was automatic route planning. A user should be able to enter an address and see the fastest route to that destination displayed on the map. The first version of the app could only build the routes over roads. People who traveled by car were bursting with joy. But apparently, not everybody likes to drive on their vacation. So with the next update, you added an option to build walking routes. Right after that, you added another option to let people use public transport in their routes.However, that was only the beginning. Later you planned to add route building for cyclists. And even later, another option for building routes through all of a city's tourist attractions. While from a business perspective the app was a success, the technical part caused you many headaches. Each time you added a new routing algorithm, the main class of the navigator doubled in size. At some point, the beast became too hard to maintain. Any change to one of the algorithms, whether it was a simple bug fix or a slight adjustment of the street score, affected the whole class, increasing the chance of creating an error in already-working code. In addition, teamwork became inefficient. Your teammates, who had been hired right after the successful release, complain that they spend too much time resolving merge conflicts. Implementing a new feature requires you to change the same huge class, conflicting with the code produced by other people."
Behavioral,Memento,"Imagine that you're creating a text editor app. In addition to simple text editing, your editor can format text, insert inline images, etc. At some point, you decided to let users undo any operations carried out on the text. This feature has become so common over the years that nowadays people expect every app to have it. For the implementation, you chose to take the direct approach. Before performing any operation, the app records the state of all objects and saves it in some storage. Later, when a user decides to revert an action, the app fetches the latest snapshot from the history and uses it to restore the state of all objects. Let's think about those state snapshots. How exactly would you produce one? You'd probably need to go over all the fields in an object and copy their values into storage. However, this would only work if the object had quite relaxed access restrictions to its contents. Unfortunately, most real objects won't let others peek inside them that easily, hiding all significant data in private fields. Ignore that problem for now and let's assume that our objects behave like hippies: preferring open relations and keeping their state public. While this approach would solve the immediate problem and let you produce snapshots of objects' states at will, it still has some serious issues. In the future, you might decide to refactor some of the editor classes, or add or remove some of the fields. Sounds easy, but this would also require changing the classes responsible for copying the state of the affected objects. But there's more. Let's consider the actual snapshot of the editor's state. What data does it contain? At a bare minimum, it must contain the actual text, cursor coordinates, current scroll position, etc. To make a snapshot, you'd need to collect these values and put them into some kind of container. Most likely, you're going to store lots of these container objects inside some list that would represent the history. Therefore the containers would probably end up being objects of one class. The class would have almost no methods, but lots of fields that mirror the editor's state. To allow other objects to write and read data to and from a snapshot, you'd probably need to make its fields public. That would expose all the editor's states, private or not. Other classes would become dependent on every little change to the snapshot class, which would otherwise happen within private fields and methods without affecting outer classes. It looks like we've reached a dead end: you either expose all internal details of classes, making them too fragile, or restrict access to their state, making it impossible to produce snapshots. Is there any other way to implement the ""undo""?"
Behavioral,Mediator,"Say you have a dialog for creating and editing customer profiles. It consists of various form controls such as text fields, checkboxes, buttons, etc.Some of the form elements may interact with others. For instance, selecting the I have a dog checkbox may reveal a hidden text field for entering the dog's name. Another example is the submit button that has to validate values of all fields before saving the data. By having this logic implemented directly inside the code of the form elements you make these elements' classes much harder to reuse in other forms of the app. For example, you won't be able to use that checkbox class inside another form, because it's coupled to the dog's text field. You can use either all the classes involved in rendering the profile form, or none at all."
Behavioral,Interpreter,"Defines a way to interpret and evaluate language grammar or expressions. It provides a mechanism to evaluate sentences in a language by representing their grammar as a set of classes. Each class represents a rule or expression in the grammar, and the pattern allows these classes to be composed hierarchically to interpret complex expressions. The pattern involves defining a hierarchy of expression classes, both terminal and nonterminal, to represent the elements of the language’s grammar. Terminal expressions represent basic building blocks, while nonterminal expressions represent compositions of these building blocks. The tree structure of the Interpreter design pattern is somewhat similar to that defined by the composite design pattern with terminal expressions being leaf objects and non-terminal expressions being composites."
Behavioral,Observer,"Imagine that you have two types of objects: a Customer and a Store. The customer is very interested in a particular brand of product (say, its a new model of the iPhone) which should become available in the store very soon. The customer could visit the store every day and check product availability. But while the product is still en route, most of these trips would be pointless. On the other hand, the store could send tons of emails (which might be considered spam) to all customers each time a new product becomes available. This would save some customers from endless trips to the store. At the same time, it'd upset other customers who aren't interested in new products. It looks like we've got a conflict. Either the customer wastes time checking product availability or the store wastes resources notifying the wrong customers."
Behavioral,Chain of Responsibility,"Imagine that you're working on an online ordering system. You want to restrict access to the system so only authenticated users can create orders. Also, users who have administrative permissions must have full access to all orders. After a bit of planning, you realized that these checks must be performed sequentially. The application can attempt to authenticate a user to the system whenever it receives a request that contains the user's credentials. However, if those credentials aren't correct and authentication fails, there's no reason to proceed with any other checks. During the next few months, you implemented several more of those sequential checks. The code of the checks, which had already looked like a mess, became more and more bloated as you added each new feature. Changing one check sometimes affected the others. Worst of all, when you tried to reuse the checks to protect other components of the system, you had to duplicate some of the code since those components required some of the checks, but not all of them. The system became very hard to comprehend and expensive to maintain. You struggled with the code for a while, until one day you decided to refactor the whole thing."
Behavioral,Iterator,"Collections are one of the most used data types in programming. Nonetheless, a collection is just a container for a group of objects. Most collections store their elements in simple lists. However, some of them are based on stacks, trees, graphs and other complex data structures. But no matter how a collection is structured, it must provide some way of accessing its elements so that other code can use these elements. There should be a way to go through each element of the collection without accessing the same elements over and over. This may sound like an easy job if you have a collection based on a list. You just loop over all of the elements. But how do you sequentially traverse elements of a complex data structure, such as a tree? For example, one day you might be just fine with depth-first traversal of a tree. Yet the next day you might require breadth-first traversal. And the next week, you might need something else, like random access to the tree elements. Adding more and more traversal algorithms to the collection gradually blurs its primary responsibility, which is efficient data storage. Additionally, some algorithms might be tailored for a specific application, so including them into a generic collection class would be weird. On the other hand, the client code that's supposed to work with various collections may not even care how they store their elements. However, since collections all provide different ways of accessing their elements, you have no option other than to couple your code to the specific collection classes."
Behavioral,State,"The State pattern is closely related to the concept of a Finite-State Machine. The main idea is that, at any given moment, there's a finite number of states which a program can be in. Within any unique state, the program behaves differently, and the program can be switched from one state to another instantaneously. However, depending on a current state, the program may or may not switch to certain other states. These switching rules, called transitions, are also finite and predetermined. You can also apply this approach to objects. Imagine that we have a Document class. A document can be in one of three states: Draft, Moderation and Published. The publish method of the document works a little bit differently in each state:State machines are usually implemented with lots of conditional statements (if or switch) that select the appropriate behavior depending on the current state of the object. Usually, this state is just a set of values of the object's fields. Even if you've never heard about finite-state machines before, you've probably implemented a state at least once. Does the following code structure ring a bell? The biggest weakness of a state machine based on conditionals reveals itself once we start adding more and more states and state-dependent behaviors to the Document class. Most methods will contain monstrous conditionals that pick the proper behavior of a method according to the current state. Code like this is very difficult to maintain because any change to the transition logic may require changing state conditionals in every method. The problem tends to get bigger as a project evolves. It's quite difficult to predict all possible states and transitions at the design stage. Hence, a lean state machine built with a limited set of conditionals can grow into a bloated mess over time."
Behavioral,Template Method,"Imagine that you're creating a data mining application that analyzes corporate documents. Users feed the app documents in various formats (PDF, DOC, CSV), and it tries to extract meaningful data from these docs in a uniform format. The first version of the app could work only with DOC files. In the following version, it was able to support CSV files. A month later, you taught it to extract data from PDF files. At some point, you noticed that all three classes have a lot of similar code. While the code for dealing with various data formats was entirely different in all classes, the code for data processing and analysis is almost identical. Wouldn't it be great to get rid of the code duplication, leaving the algorithm structure intact? There was another problem related to client code that used these classes. It had lots of conditionals that picked a proper course of action depending on the class of the processing object. If all three processing classes had a common interface or a base class, you'd be able to eliminate the conditionals in client code and use polymorphism when calling methods on a processing object."
Structural,Proxy,"Why would you want to control access to an object? Here is an example: you have a massive object that consumes a vast amount of system resources. You need it from time to time, but not always.You could implement lazy initialization: create this object only when it's actually needed. All of the object's clients would need to execute some deferred initialization code. Unfortunately, this would probably cause a lot of code duplication. In an ideal world, we'd want to put this code directly into our object's class, but that isn't always possible. For instance, the class may be part of a closed 3rd-party library."
Structural,Flyweight,"To have some fun after long working hours, you decided to create a simple video game: players would be moving around a map and shooting each other. You chose to implement a realistic particle system and make it a distinctive feature of the game. Vast quantities of bullets, missiles, and shrapnel from explosions should fly all over the map and deliver a thrilling experience to the player. Upon its completion, you pushed the last commit, built the game and sent it to your friend for a test drive. Although the game was running flawlessly on your machine, your friend wasn't able to play for long. On his computer, the game kept crashing after a few minutes of gameplay. After spending several hours digging through debug logs, you discovered that the game crashed because of an insufficient amount of RAM. It turned out that your friend's rig was much less powerful than your own computer, and that's why the problem emerged so quickly on his machine. The actual problem was related to your particle system. Each particle, such as a bullet, a missile or a piece of shrapnel was represented by a separate object containing plenty of data. At some point, when the carnage on a player's screen reached its climax, newly created particles no longer fit into the remaining RAM, so the program crashed."
Structural,Facade,"Imagine that you must make your code work with a broad set of objects that belong to a sophisticated library or framework. Ordinarily, you'd need to initialize all of those objects, keep track of dependencies, execute methods in the correct order, and so on. As a result, the business logic of your classes would become tightly coupled to the implementation details of 3rd-party classes, making it hard to comprehend and maintain."
Structural,Composite,"Using the Composite pattern makes sense only when the core model of your app can be represented as a tree. For example, imagine that you have two types of objects: Products and Boxes. A Box can contain several Products as well as a number of smaller Boxes. These little Boxes can also hold some Products or even smaller Boxes, and so on.Say you decide to create an ordering system that uses these classes. Orders could contain simple products without any wrapping, as well as boxes stuffed with products...and other boxes. How would you determine the total price of such an order? You could try the direct approach: unwrap all the boxes, go over all the products and then calculate the total. That would be doable in the real world; but in a program, it's not as simple as running a loop. You have to know the classes of Products and Boxes you're going through, the nesting level of the boxes and other nasty details beforehand. All of this makes the direct approach either too awkward or even impossible."
Structural,Decorator,"Imagine that you're working on a notification library which lets other programs notify their users about important events. The initial version of the library was based on the Notifier class that had only a few fields, a constructor and a single send method. The method could accept a message argument from a client and send the message to a list of emails that were passed to the notifier via its constructor. A third-party app which acted as a client was supposed to create and configure the notifier object once, and then use it each time something important happened. At some point, you realize that users of the library expect more than just email notifications. Many of them would like to receive an SMS about critical issues. Others would like to be notified on Facebook and, of course, the corporate users would love to get Slack notifications. How hard can that be? You extended the Notifier class and put the additional notification methods into new subclasses. Now the client was supposed to instantiate the desired notification class and use it for all further notifications. But then someone reasonably asked you, Why can't you use several notification types at once? If your house is on fire, you'd probably want to be informed through every channel. You tried to address that problem by creating special subclasses which combined several notification methods within one class. However, it quickly became apparent that this approach would bloat the code immensely, not only the library code but the client code as well. You have to find some other way to structure notifications classes so that their number won't accidentally break some Guinness record."
Structural,Bridge,"Abstraction? Implementation? Sound scary? Stay calm and let's consider a simple example. Say you have a geometric Shape class with a pair of subclasses: Circle and Square. You want to extend this class hierarchy to incorporate colors, so you plan to create Red and Blue shape subclasses. However, since you already have two subclasses, you'll need to create four class combinations such as BlueCircle and RedSquare. Adding new shape types and colors to the hierarchy will grow it exponentially. For example, to add a triangle shape you'd need to introduce two subclasses, one for each color. And after that, adding a new color would require creating three subclasses, one for each shape type. The further we go, the worse it becomes."
Creational,Singleton,"The Singleton pattern solves two problems at the same time, violating the Single Responsibility Principle: Nowadays, the Singleton pattern has become so popular that people may call something a singleton even if it solves just one of the listed problems."
Structural,Adapter,"Imagine that you're creating a stock market monitoring app. The app downloads the stock data from multiple sources in XML format and then displays nice-looking charts and diagrams for the user. At some point, you decide to improve the app by integrating a smart 3rd-party analytics library. But there's a catch: the analytics library only works with data in JSON format. You could change the library to work with XML. However, this might break some existing code that relies on the library. And worse, you might not have access to the library's source code in the first place, making this approach impossible."
Creational,Builder,"Imagine a complex object that requires laborious, step-by-step initialization of many fields and nested objects. Such initialization code is usually buried inside a monstrous constructor with lots of parameters. Or even worse: scattered all over the client code. For example, let's think about how to create a House object. To build a simple house, you need to construct four walls and a floor, install a door, fit a pair of windows, and build a roof. But what if you want a bigger, brighter house, with a backyard and other goodies (like a heating system, plumbing, and electrical wiring)? The simplest solution is to extend the base House class and create a set of subclasses to cover all combinations of the parameters. But eventually you'll end up with a considerable number of subclasses. Any new parameter, such as the porch style, will require growing this hierarchy even more. There's another approach that doesn't involve breeding subclasses. You can create a giant constructor right in the base House class with all possible parameters that control the house object. While this approach indeed eliminates the need for subclasses, it creates another problem. In most cases most of the parameters will be unused, making the constructor calls pretty ugly. For instance, only a fraction of houses have swimming pools, so the parameters related to swimming pools will be useless nine times out of ten."
Creational,Prototype,"Say you have an object, and you want to create an exact copy of it. How would you do it? First, you have to create a new object of the same class. Then you have to go through all the fields of the original object and copy their values over to the new object.Nice! But there's a catch. Not all objects can be copied that way because some of the object's fields may be private and not visible from outside of the object itself. There's one more problem with the direct approach. Since you have to know the object's class to create a duplicate, your code becomes dependent on that class. If the extra dependency doesn't scare you, there's another catch. Sometimes you only know the interface that the object follows, but not its concrete class, when, for example, a parameter in a method accepts any objects that follow some interface."
Creational,Abstract Factory,"Imagine that you're creating a furniture shop simulator. Your code consists of classes that represent: You need a way to create individual furniture objects so that they match other objects of the same family. Customers get quite mad when they receive non-matching furniture. Also, you don't want to change existing code when adding new products or families of products to the program. Furniture vendors update their catalogs very often, and you wouldn't want to change the core code each time it happens."
Creational,Factory Method,"Imagine that you're creating a logistics management application. The first version of your app can only handle transportation by trucks, so the bulk of your code lives inside the Truck class. After a while, your app becomes pretty popular. Each day you receive dozens of requests from sea transportation companies to incorporate sea logistics into the app. Great news, right? But how about the code? At present, most of your code is coupled to the Truck class. Adding Ships into the app would require making changes to the entire codebase. Moreover, if later you decide to add another type of transportation to the app, you will probably need to make all of these changes again. As a result, you will end up with pretty nasty code, riddled with conditionals that switch the app's behavior depending on the class of transportation objects."
Behavioral,Visitor,"Represent an operation to be performed on the elements of an object structure.  Visitor lets you define a new operation without changing the classes of the elements on which it operates. The classic technique for recovering lost type information. Do the right thing based on the type of two objects. Double dispatch. Many distinct and unrelated operations need to be performed on node objects in a heterogeneous aggregate structure.  You want to avoid ""polluting"" the node classes with these operations.  And, you don't want to have to query the type of each node and cast the pointer to the correct type before performing the desired operation.Visitor's primary purpose is to abstract functionality that can be applied to an aggregate hierarchy of ""element"" objects.  The approach encourages designing lightweight Element classes - because processing functionality is removed from their list of responsibilities.  New functionality can easily be added to the original inheritance hierarchy by creating a new Visitor subclass.Visitor implements ""double dispatch"".  OO messages routinely manifest ""single dispatch"" - the operation that is executed depends on: the name of the request, and the type of the receiver.  In ""double dispatch"", the operation executed depends on:  the name of the request, and the type of TWO receivers (the type of the Visitor and the type of the element it visits).The implementation proceeds as follows.  Create a Visitor class hierarchy that defines a pure virtual visit() method in the abstract base class for each concrete derived class in the aggregate node hierarchy.  Each visit() method accepts a single argument - a pointer or reference to an original Element derived class.Each operation to be supported is modelled with a concrete derived class of the Visitor hierarchy.  The visit() methods declared in the Visitor base class are now defined in each derived subclass by allocating the ""type query and cast"" code in the original implementation to the appropriate overloaded visit() method.Add a single pure virtual accept() method to the base class of the Element hierarchy.  accept() is defined to receive a single argument - a pointer or reference to the abstract base class of the Visitor hierarchy.Each concrete derived class of the Element hierarchy implements the accept() method by simply calling the visit() method on the concrete derived instance of the Visitor hierarchy that it was passed, passing its ""this"" pointer as the sole argument.Everything for ""elements"" and ""visitors"" is now set-up.  When the client needs an operation to be performed, (s)he creates an instance of the Visitor object, calls the accept() method on each Element object, and passes the Visitor object.The accept() method causes flow of control to find the correct Element subclass.  Then when the visit() method is invoked, flow of control is vectored to the correct Visitor subclass. accept() dispatch plus visit() dispatch equals double dispatch.The Visitor pattern makes adding new operations (or utilities) easy - simply add a new Visitor derived class.  But, if the subclasses in the aggregate node hierarchy are not stable, keeping the Visitor subclasses in sync requires a prohibitive amount of effort.An acknowledged objection to the Visitor pattern is that is represents a regression to functional decomposition - separate the algorithms from the data structures.  While this is a legitimate interpretation, perhaps a better perspective/rationale is the goal of promoting non-traditional behavior to full object status."
Behavioral,Template Method,"Define the skeleton of an algorithm in an operation, deferring some steps to client subclasses.  Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm's structure.Base class declares algorithm 'placeholders', and derived classes implement the placeholders.Two different components have significant similarities, but demonstrate no reuse of common interface or implementation.  If a change common to both components becomes necessary, duplicate effort must be expended.The component designer decides which steps of an algorithm are invariant (or standard), and which are variant (or customizable).  The invariant steps are implemented in an abstract base class, while the variant steps are either given a default implementation, or no implementation at all.  The variant steps represent ""hooks"", or ""placeholders"", that can, or must, be supplied by the component's client in a concrete derived class.The component designer mandates the required steps of an algorithm, and the ordering of the steps, but allows the component client to extend or replace some number of these steps.Template Method is used prominently in frameworks.  Each framework implements the invariant pieces of a domain's architecture, and defines ""placeholders"" for all necessary or interesting client customization options.  In so doing, the framework becomes the ""center of the universe"", and the client customizations are simply ""the third rock from the sun"".  This inverted control structure has been affectionately labelled ""the Hollywood principle"" - ""don't call us, we'll call you""."
Behavioral,Mediator,"Define an object that encapsulates how a set of objects interact. Mediator promotes loose coupling by keeping objects from referring to each other explicitly, and it lets you vary their interaction independently.Design an intermediary to decouple many peers.Promote the many-to-many relationships between interacting peers to ""full object status"".We want to design reusable components, but dependencies between the potentially reusable pieces demonstrates the ""spaghetti code"" phenomenon (trying to scoop a single serving results in an ""all or nothing clump""). In Unix, permission to access system resources is managed at three levels of granularity: world, group, and owner.  A group is a collection of users intended to model some functional affiliation.  Each user on the system can be a member of one or more groups, and each group can have zero or more users assigned to it. Next figure shows three users that are assigned to all three groups. If we were to model this in software, we could decide to have User objects coupled to Group objects, and Group objects coupled to User objects.  Then when changes occur, both classes and all their instances would be affected.An alternate approach would be to introduce ""an additional level of indirection"" - take the mapping of users to groups and groups to users, and make it an abstraction unto itself.  This offers several advantages: Users and Groups are decoupled from one another, many mappings can easily be maintained and manipulated simultaneously, and the mapping abstraction can be extended in the future by defining derived classes. Partitioning a system into many objects generally enhances reusability, but proliferating interconnections between those objects tend to reduce it again.  The mediator object: encapsulates all interconnections, acts as the hub of communication, is responsible for controlling and coordinating the interactions of its clients, and promotes loose coupling by keeping objects from referring to each other explicitly.The Mediator pattern promotes a ""many-to-many relationship network"" to ""full object status"".  Modelling the inter-relationships with an object enhances encapsulation, and allows the behavior of those inter-relationships to be modified or extended through subclassing.An example where Mediator is useful is the design of a user and group capability in an operating system.  A group can have zero or more users, and, a  user can be a member of zero or more groups.  The Mediator pattern provides a flexible and non-invasive way to associate and manage users and groups."
Behavioral,Interpreter,"Given a language, define a representation for its grammar along with an interpreter that uses the representation to interpret sentences in the language.Map a domain to a language, the language to a grammar, and the grammar to a hierarchical object-oriented design.A class of problems occurs repeatedly in a well-defined and well-understood domain.  If the domain were characterized with a ""language"", then problems could be easily solved with an interpretation ""engine"".The Interpreter pattern discusses: defining a domain language (i.e. problem characterization) as a simple language grammar, representing domain rules as language sentences, and interpreting these sentences to solve the problem.  The pattern uses a class to represent each grammar rule.  And since grammars are usually hierarchical in structure, an inheritance hierarchy of rule classes maps nicely.An abstract base class specifies the method interpret().  Each concrete subclass implements interpret() by accepting (as an argument) the current state of the language stream, and adding its contribution to the problem solving process."
Behavioral,Iterator,"Provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation.The C++ and Java standard library abstraction that makes it possible to decouple collection classes and algorithms.Promote to ""full object status"" the traversal of a collection.Polymorphic traversalNeed to ""abstract"" the traversal of wildly different data structures so that algorithms can be defined that are capable of interfacing with each transparently.""An aggregate object such as a list should give you a way to access its elements without exposing its internal structure.  Moreover, you might want to traverse the list in different ways, depending on what you need to accomplish.  But you probably don't want to bloat the List interface with operations for different traversals, even if you could anticipate the ones you'll require.  You might also need to have more than one traversal pending on the same list."" And, providing a uniform interface for traversing many types of aggregate objects (i.e. polymorphic iteration) might be valuable.The Iterator pattern lets you do all this.  The key idea is to take the responsibility for access and traversal out of the aggregate object and put it into an Iterator object that defines a standard traversal protocol.The Iterator abstraction is fundamental to an emerging technology called ""generic programming"".  This strategy seeks to explicitly separate the notion of ""algorithm"" from that of ""data structure"".  The motivation is to: promote component-based development, boost productivity, and reduce configuration management. As an example, if you wanted to support four data structures (array, binary tree, linked list, and hash table) and three algorithms (sort, find, and merge), a traditional approach would require four times three permutations to develop and maintain.  Whereas, a generic programming approach would only require four plus three configuration items."
Behavioral,Command,"Encapsulate a request as an object, thereby letting you parametrize clients with different requests, queue or log requests, and support undoable operations.Promote ""invocation of a method on an object"" to full object statusAn object-oriented callbackNeed to issue requests to objects without knowing anything about the operation being requested or the receiver of the request.Command decouples the object that invokes the operation from the one that knows how to perform it.  To achieve this separation, the designer creates an abstract base class that maps a receiver (an object) with an action (a pointer to a member function).  The base class contains an execute() method that simply calls the action on the receiver.All clients of Command objects treat each object as a ""black box"" by simply invoking the object's virtual execute() method whenever the client requires the object's ""service"".A Command class holds some subset of the following: an object, a method to be applied to the object, and the arguments to be passed when the method is applied.  The Command's ""execute"" method then causes the pieces to come together.Sequences of Command objects can be assembled into composite (or macro) commands."
Behavioral,Strategy,"Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from the clients that use it.Capture the abstraction in an interface, bury implementation details in derived classes.One of the dominant strategies of object-oriented design is the ""open-closed principle"".Figure demonstrates how this is routinely achieved - encapsulate interface details in a base class, and bury implementation details in derived classes.  Clients can then couple themselves to an interface, and not have to experience the upheaval associated with change: no impact when the number of derived classes changes, and no impact when the implementation of a derived class changes. A generic value of the software community for years has been, ""maximize cohesion and minimize coupling"".  The object-oriented design approach shown in figure is all about minimizing coupling.  Since the client is coupled only to an abstraction (i.e. a useful fiction), and not a particular realization of that abstraction, the client could be said to be practicing ""abstract coupling"" . an object-oriented variant of the more generic exhortation ""minimize coupling"".A more popular characterization of this ""abstract coupling"" principle is ""Program to an interface, not an implementation"".Clients should prefer the ""additional level of indirection"" that an interface (or an abstract base class) affords. The interface captures the abstraction (i.e. the ""useful fiction"") the client wants to exercise, and the implementations of that interface are effectively hidden."
Behavioral,Memento,"Without violating encapsulation, capture and externalize an object's internal state so that the object can be returned to this state later.A magic cookie that encapsulates a ""check point"" capability. Promote undo or rollback to full object status.Need to restore an object back to its previous state (e.g. ""undo"" or ""rollback"" operations).The client requests a Memento from the source object when it needs to checkpoint the source object's state.  The source object initializes the Memento with a characterization of its state.  The client is the ""care-taker"" of the Memento, but only the source object can store and retrieve information from the Memento (the Memento is ""opaque"" to the client and all other objects).  If the client subsequently needs to ""rollback"" the source object's state, it hands the Memento back to the source object for reinstatement. An unlimited ""undo"" and ""redo"" capability can be readily implemented with a stack of Command objects and a stack of Memento objects."
Behavioral,Observer,"Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.Encapsulate the core (or common or engine) components in a Subject abstraction, and the variable (or optional or user interface) components in an Observer hierarchy.The ""View"" part of Model-View-Controller.A large monolithic design does not scale well as new graphing or monitoring requirements are levied.Define an object that is the ""keeper"" of the data model and/or business logic (the Subject).  Delegate all ""view"" functionality to decoupled and distinct Observer objects.  Observers register themselves with the Subject as they are created.  Whenever the Subject changes, it broadcasts to all registered Observers that it has changed, and each Observer queries the Subject for that subset of the Subject's state that it is responsible for monitoring.This allows the number and ""type"" of ""view"" objects to be configured dynamically, instead of being statically specified at compile-time.The protocol described above specifies a ""pull""  interaction model.  Instead of the Subject ""pushing"" what has changed to all Observers, each Observer is responsible for ""pulling"" its particular ""window of interest"" from the Subject.  The ""push"" model compromises reuse, while the ""pull"" model is less efficient.Issues that  are discussed, but left to the discretion of the designer, include:  implementing event compression (only sending a single change broadcast after a series of consecutive changes has occurred), having a single Observer monitoring multiple Subjects, and ensuring that a Subject notify its Observers when it is about to go away.The Observer pattern captures the lion's share of the Model-View-Controller architecture that has been a part of the Smalltalk community for years."
Behavioral,State,"Allow an object to alter its behavior when its internal state changes. The object will appear to change its class.An object-oriented state machinewrapper + polymorphic wrappee + collaborationA monolithic object's behavior is a function of its state, and it must change its behavior at run-time depending on that state.  Or, an application is characterized by large and numerous case statements that vector flow of control based on the state of the application.The State pattern is a solution to the problem of how to make behavior depend on state. Define a ""context"" class to present a single interface to the outside world.Define a State abstract base class.Represent the different ""states"" of the state machine as derived classes of the State base class.Define state-specific behavior in the appropriate State derived classes.Maintain a pointer to the current ""state"" in the ""context"" class.To change the state of the state machine, change the current ""state"" pointer.The State pattern does not specify where the state transitions will be defined.  The choices are two: the ""context"" object, or each individual State derived class.  The advantage of the latter option is ease of adding new State derived classes.  The disadvantage is each State derived class has knowledge of (coupling to) its siblings, which introduces dependencies between subclasses.A table-driven approach to designing finite state machines does a good job of specifying state transitions, but it is difficult to add actions to accompany the state transitions.  The pattern-based approach uses code (instead of data structures) to specify state transitions, but it does a good job of accommodating state transition actions."
Behavioral,Chain of Responsibility,"Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request.  Chain the receiving objects and pass the request along the chain until an object handles it.Launch-and-leave requests with a single processing pipeline that contains many possible handlers.An object-oriented linked list with recursive traversal.There is a potentially variable number of ""handler"" or ""processing element"" or ""node"" objects, and a stream of requests that must be handled.  Need to efficiently process the requests without hard-wiring handler relationships and precedence, or request-to-handler mappings. Encapsulate the processing elements inside a ""pipeline"" abstraction; and have clients ""launch and leave"" their requests at the entrance to the pipeline. The pattern chains the receiving objects together, and then passes any request messages from object to object until it reaches an object capable of handling the message.  The number and type of handler objects isn't known a priori, they can be configured dynamically.  The chaining mechanism uses recursive composition to allow an unlimited number of handlers to be linked.Chain of Responsibility simplifies object interconnections.  Instead of senders and receivers maintaining references to all candidate receivers, each sender keeps a single reference to the head of the chain, and each receiver keeps a single reference to its immediate successor in the chain.Make sure there exists a ""safety net"" to ""catch"" any requests which go unhandled.Do not use Chain of Responsibility when each request is only handled by one handler, or, when the client object knows which service object should handle the request. "
Creational,Singleton,"Ensure a class has only one instance, and provide a global point of access to it. Encapsulated ""just-in-time initialization"" or ""initialization on first use"". Application needs one, and only one, instance of an object.  Additionally, lazy initialization and global access are necessary.Make the class of the single instance object responsible for creation, initialization, access, and enforcement.  Declare the instance as a private static data member.  Provide a public static member function that encapsulates all initialization code, and provides access to the instance.The client calls the accessor function (using the class name and scope resolution operator) whenever a reference to the single instance is required.Singleton should be considered only if all three of the following criteria are satisfied:Ownership of the single instance cannot be reasonably assignedLazy initialization is desirableGlobal access is not otherwise provided forIf ownership of the single instance, when and how initialization occurs, and global access are not issues, Singleton is not sufficiently interesting.The Singleton pattern can be extended to support access to an application-specific number of instances.The ""static member function accessor"" approach will not support subclassing of the Singleton class.  If subclassing is desired, refer to the discussion in the book.Deleting a Singleton class/instance is a non-trivial design problem. See ""To Kill A Singleton"" by John Vlissides for a discussion."
Creational,Prototype,"Specify the kinds of objects to create using a prototypical instance, and create new objects by copying this prototype.Co-opt one instance of a class for use as a breeder of all future instances.The new operator considered harmful.Application ""hard wires"" the class of object to create in each ""new"" expression.Declare an abstract base class that specifies a pure virtual ""clone"" method, and, maintains a dictionary of all ""cloneable"" concrete derived classes.  Any class that needs a ""polymorphic constructor"" capability: derives itself from the abstract base class, registers its prototypical instance, and implements the clone() operation.The client then, instead of writing code that invokes the ""new"" operator on a hard-wired class name, calls a ""clone"" operation on the abstract base class, supplying a string or enumerated data type that designates the particular concrete derived class desired."
Creational,Builder,"Separate the construction of a complex object from its representation so that the same construction process can create different representations.Parse a complex representation, create one of several targets.An application needs to create the elements of a complex aggregate. The specification for the aggregate exists on secondary storage and one of many representations needs to be built in primary storage.Separate the algorithm for interpreting (i.e. reading and parsing) a stored persistence mechanism (e.g. RTF files) from the algorithm for building and representing one of many target products (e.g. ASCII, TeX, text widget).  The focus/distinction is on creating complex aggregates.The ""director"" invokes ""builder"" services as it interprets the external format.  The ""builder"" creates part of the complex object each time it is called and maintains all intermediate state.  When the product is finished, the client retrieves the result from the ""builder"".Affords finer control over the construction process.  Unlike creational patterns that construct products in one shot, the Builder pattern constructs the product step by step under the control of the ""director""."
Structural,Proxy,"Provide a surrogate or placeholder for another object to control access to it.Use an extra level of indirection to support distributed, controlled, or intelligent access.Add a wrapper and delegation to protect the real component from undue complexity.You need to support resource-hungry objects, and you do not want to instantiate such objects unless and until they are actually requested by the client.Design a surrogate, or proxy, object that: instantiates the real object the first time the client makes a request of the proxy, remembers the identity of this real object, and forwards the instigating request to this real object.  Then all subsequent requests are simply forwarded directly to the encapsulated real object.There are four common situations in which the Proxy pattern is applicable.Counting the number of references to the real object so that it can be freed automatically when there are no more references (aka smart pointer),Loading a persistent object into memory when it's first referenced,Checking that the real object is locked before it is accessed to ensure that no other object can change it."
Creational,Factory Method,"Define an interface for creating an object, but let subclasses decide which class to instantiate.  Factory Method lets a class defer instantiation to subclasses.Defining a ""virtual"" constructor.The new operator considered harmful.A framework needs to standardize the architectural model for a range of applications, but allow for individual applications to define their own domain objects and provide for their instantiation.Factory Method is to creating objects as Template Method is to implementing an algorithm.  A superclass specifies all standard and generic behavior (using pure virtual ""placeholders"" for creation steps), and then delegates the creation details to subclasses that are supplied by the client.Factory Method makes a design more customizable and only a little more complicated.  Other design patterns require new classes, whereas Factory Method only requires a new operation.People often use Factory Method as the standard way to create objects; but it isn't necessary if: the class that's instantiated never changes, or instantiation takes place in an operation that subclasses can easily override (such as an initialization operation).Factory Method is similar to Abstract Factory but without the emphasis on families.Factory Methods are routinely specified by an architectural framework, and then implemented by the user of the framework."
Creational,Abstract Factory,"Provide an interface for creating families of related or dependent objects without specifying their concrete classes. A hierarchy that encapsulates: many possible ""platforms"", and the construction of a suite of ""products"". The new operator considered harmful. If an application is to be portable, it needs to encapsulate platform dependencies.  These ""platforms"" might include: windowing system, operating system, database, etc.  Too often, this encapsulation is not engineered in advance, and lots of #ifdef case statements with options for all currently supported platforms begin to procreate like rabbits throughout the code.Provide a level of indirection that abstracts the creation of families of related or dependent objects without directly specifying their concrete classes.  The ""factory"" object has the  esponsibility for providing creation services for the entire platform family.  Clients never create platform objects directly, they ask the factory to do that for them.This mechanism makes exchanging product families easy because the specific class of the factory object appears only once in the application - where it is instantiated.  The application can wholesale replace the entire family of products simply by instantiating a different concrete instance of the abstract factory. Because the service provided by the factory object is so pervasive, it is routinely implemented as a Singleton."
Structural,Facade,"Provide a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use. Wrap a complicated subsystem with a simpler interface. A segment of the client community needs a simplified interface to the overall functionality of a complex subsystem. Facade discusses encapsulating a complex subsystem within a single interface object.  This reduces the learning curve necessary to successfully leverage the subsystem.  It also promotes decoupling the subsystem from its potentially many clients.  On the other hand, if the Facade is the only access point for the subsystem, it will limit the features and flexibility that ""power users"" may need. The Facade object should be a fairly simple advocate or facilitator. It should not become an all-knowing oracle or ""god"" object."
Structural,Flyweight,"Use sharing to support large numbers of fine-grained objects efficiently. The Motif GUI strategy of replacing heavy-weight widgets with light-weight gadgets. Designing objects down to the lowest levels of system ""granularity"" provides optimal flexibility, but can be unacceptably expensive in terms of performance and memory usage. The Flyweight pattern describes how to share objects to allow their use at fine granularity without prohibitive cost. Each ""flyweight"" object is divided into two pieces:  the state-dependent (extrinsic) part, and the state-independent (intrinsic) part.  Intrinsic state is stored (shared) in the Flyweight object.  Extrinsic state is stored or computed by client objects, and passed to the Flyweight when its operations are invoked. An illustration of this approach would be Motif widgets that have been re-engineered as light-weight gadgets.  Whereas widgets are ""intelligent"" enough to stand on their own; gadgets exist in a dependent relationship with their parent layout manager widget.  Each layout manager provides context-dependent event handling, real estate management, and resource services to its flyweight gadgets, and each gadget is only responsible for context-independent state and behavior."
Structural,Composite,"Compose objects into tree structures to represent whole-part hierarchies.  Composite lets clients treat individual objects and compositions of objects uniformly.Recursive composition""Directories contain entries, each of which could be a directory.""1-to-many ""has a"" up the ""is a"" hierarchyApplication needs to manipulate a hierarchical collection of ""primitive"" and ""composite"" objects.  Processing of a primitive object is handled one way, and processing of a composite object is handled differently. Having to query the ""type"" of each object before attempting to process it is not desirable. Define an abstract base class (Component) that specifies the behavior that needs to be exercised uniformly across all primitive and composite objects. Subclass the Primitive and Composite classes off of the Component class. Each Composite object ""couples"" itself only to the abstract type Component as it manages its ""children"". Use this pattern whenever you have ""composites that contain components, each of which could be a composite"".Child management methods [e.g. addChild(), removeChild()] should normally be defined in the Composite class.  Unfortunately, the desire to treat Primitives and Composites uniformly requires that these methods be moved to the abstract Component class.  See the ""Opinions"" section below for a discussion of ""safety"" versus  transparency"" issues."
Structural,Decorator,"Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality. Client-specified embellishment of a core object by recursively wrapping it. Wrapping a gift, putting it in a box, and wrapping the box. You want to add behavior or state to individual objects at run-time. Inheritance is not feasible because it is static and applies to an entire class. Suppose you are working on a user interface toolkit and you wish to support adding borders and scroll bars to windows. You could define an inheritance hierarchy like ... But the Decorator pattern suggests giving the client the ability to specify whatever combination of ""features"" is desired. This flexibility can be achieved with the following design. Another example of cascading (or chaining) features together to produce a custom object might look like ...The solution to this class of problems involves encapsulating the original object inside an abstract  wrapper interface.  Both the decorator objects and the core object inherit from this abstract interface.  The interface uses recursive composition to allow an unlimited number of decorator ""layers"" to be added to each core object.Note that this pattern allows responsibilities to be added to an object, not methods to an object's interface.  The interface presented to the client must remain constant as successive layers are specified.Also note that the core object's identity has now been ""hidden"" inside of a decorator object.  Trying to access the core object directly is now a problem."
Structural,Adapter,"Convert the interface of a class into another interface clients expect.  Adapter lets classes work together that couldn't otherwise because of incompatible interfaces. Wrap an existing class with a new interface.Impedance match an old component to a new systemAn ""off the shelf"" component offers compelling functionality that you would like to reuse, but its ""view of the world"" is not compatible with the philosophy and architecture of the system currently being developed.Reuse has always been painful and elusive.  One reason has been the tribulation of designing something new, while reusing something old. There is always something not quite right between the old and the new. It may be physical dimensions or misalignment.  It may be timing or synchronization.  It may be unfortunate assumptions or competing standards.It is like the problem of inserting a new three-prong electrical plug in an old two-prong wall outlet â€“ some kind of adapter or intermediary is necessary. Adapter is about creating an intermediary abstraction that translates, or maps, the old component to the new system.  Clients call methods on the Adapter object which redirects them into calls to the legacy component.  This strategy can be implemented either with inheritance or with aggregation.Adapter functions as a wrapper or modifier of an existing class.  It provides a different or translated view of that class."
Structural,Bridge,"Decouple an abstraction from its implementation so that the two can vary independently. Publish interface in an inheritance hierarchy, and bury implementation in its own inheritance hierarchy. Beyond encapsulation, to insulation""Hardening of the software arteries"" has occurred by using subclassing of an abstract base class to provide alternative implementations.  This locks in compile-time binding between interface and implementation. The abstraction and implementation cannot be independently extended or composed. Consider the domain of ""thread scheduling"". There are two types of thread schedulers, and two types of operating systems or ""platforms"".  Given this approach to specialization, we have to define a class for each permutation of these two dimensions. If we add a new platform (say ... Java's Virtual Machine), what would our hierarchy look like? What if we had three kinds of thread schedulers, and four kinds of platforms?  What if we had five kinds of thread schedulers, and ten kinds of platforms?  The number of classes we would have to define is the product of the number of scheduling schemes and the number of platforms.The Bridge design pattern proposes refactoring this exponentially explosive inheritance hierarchy into two orthogonal hierarchies, one for platform-independent abstractions, and the other for platform-dependent implementations. Decompose the component's interface and implementation into orthogonal class hierarchies.  The interface class contains a pointer to the abstract implementation class.  This pointer is initialized with an instance of a concrete implementation class, but all subsequent interaction from the interface class to the implementation class is limited to the abstraction maintained in the implementation base class.  The client interacts with the interface class, and it in turn ""delegates"" all requests to the implementation class. The interface object is the ""handle"" known and used by the client; while the implementation object, or ""body"", is safely encapsulated to ensure that it may continue to evolve, or be entirely replaced (or shared at run-time. Use the Bridge pattern when: you want run-time binding of the implementation,you have a proliferation of classes resulting from a coupled interface and numerous implementations,you want to share an implementation among multiple objects,you need to map orthogonal class hierarchies. Consequences include:decoupling the object's interface,improved extensibility (you can extend (i.e. subclass) the abstraction and implementation hierarchies independently),hiding details from clients.Bridge is a synonym for the ""handle/body"" idiom.  This is a design mechanism that encapsulates an implementation class inside of an interface class.  The former is the body, and the latter is the handle.  The handle is viewed by the user as the actual class, but the work is done in the body. ""The handle/body class idiom may be used to decompose a complex abstraction into smaller, more manageable classes.  The idiom may reflect the sharing of a single resource by multiple classes that control access to it (e.g. reference counting)."""
Creational,Abstract Factory,"Allows the creation of objects without specifying their concrete type. The abstract factory pattern is one of the classic Gang of Four creational design patterns used to create families of objects, where the objects of a family are designed to work together. In the abstract factory pattern you provide an interface to create families of related or dependent objects, but you do not specify the concrete classes of the objects to create. From the client point of view, it means that a client can create a family of related objects without knowing about the object definitions and their concrete class names. abstract factory pattern uses composition. object to create families of objects.object to create families of objects."
Creational,Builder,"Used to create complex objects. Separate the construction of a complex object from its representation so that the same construction process can create different representations. The builder pattern allows you to enforce a step-by-step process to construct a complex object as a finished product. In this pattern, the step-by-step construction process remains same but the finished products can have different representations."
Creational,Factory Method,"Creates objects without specifying the exact class to create. creation of objects in an application. As the name suggests, the factory method pattern makes use of classes that acts as factories to create objects. This pattern favors method invocation instead of making direct constructor calls to create objects. In the factory method pattern, you provide an interface, which can be a Java interface or an abstract class to create objects. A factory method in the interface defers the object creation to one or more concrete subclasses at run time. The subclasses implement the factory method to select the class whose objects need to be created."
Creational,Prototype,"Creates a new object from an existing object. Specify the kinds of objects to create using a prototypical instance, and create new objects by copying this prototype. Using the prototype pattern, you do not create a new object for each client requesting the object. Instead, you start by creating a single object, called a prototype and make copies of it for each client requesting the object. In Java, this is achieved through object cloning, a way to make a copy of an object with the same state as the original object. But why create copies if we can create new objects through constructor calls, which is much simpler? Most of the time you will not need to create copies of objects. But, as you move into enterprise application development where application performance is critical, you will encounter situations where construction of an object involves time consuming operations, such as network communication, database reads, and disk I/O. If a large number of such objects needs to be created, you can avoid repeating those steps for each object by initially creating a prototype and then making copies of it."
Creational,Singleton,"Ensures only one instance of an object is created. a class which can only be instantiated once, and a global point of access to that instance is provided. If an instance has already been created, the constructor simply returns a reference to that object. This is the simplest implementation of the Singleton design pattern. the constructor of the SingletonClass class is made private, to make sure that there is no other way to instantiate the class. This example is known as lazy initialization – which means that it restricts the creation of the instance until it is requested for the first time. There are situations in which a singleton class is useful. Typical examples are classes that we could shortly describe as “managers”. These are classes which manage resources, read data from configuration files, instantiate threads etc."
Structural,Adapter,Allows for two incompatible classes to work together by wrapping an interface around one of the existing classes. Convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldnt otherwise because of incompatible interfaces. This pattern is typically used when an incompatible module needs to be integrated with an existing module without making any source code modifications.
Structural,Bridge,"Decouples an abstraction so two classes can vary independently. We use abstraction to decouple client code from implementations, and the usual way is to use inheritance. We define an interface or an abstract class and create inheritance hierarchies from it, one for each of the several possible implementations. Although at first look this approach appears logical and nothing wrong in it, abstractions through inheritance isnt always flexible. When we use inheritance, we are permanently binding the implementation to the abstraction. As a result, any change made to one affects the other. A more flexible way is to separate the abstraction and the implementation, and this is where the bridge pattern comes in. identify how to realize relationships between classes and objects in a simple way. The bridge pattern does it by separating the abstraction and the implementation in separate class hierarchies. The bridge between the class hierarchies is achieved through composition."
Structural,Composite,"Takes a group of objects into a single object. Compose objects into tree structures to represent part-whole hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly. Using this pattern, you can create hierarchical object trees in a uniform manner without going through complexities, such as object casting, type evaluations, and conditional checks to see if one object is independent or contains other objects."
Structural,Decorator,"Allows for an objects behavior to be extended dynamically at run time. Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality. Instead, you can attach new responsibility to an object dynamically. This is exactly the intended use of the decorator pattern.  Per the Gang of Four – “Attach additional responsibilities to an object dynamically”.  But how do you do this? By using Composition. With composition, you can dynamically add multiple new responsibilities to objects at run time. The great thing here is that the object doesnt need to be aware of it, and your design conforms to the Open Closed Principle. We often look to the elegance of a great object-oriented programming language, while overlooking the simplicity of using composition to solve a problem."
Structural,Facade,Provides a simple interface to a more complex underlying object. Provide a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use. The facade handles the underlying interactions with the subsystem services transparently from the clients. Delegates client requests to appropriate subsystem classes.
Structural,Flyweight,"Reduces the cost of complex object models. Use sharing to support large numbers of fine-grained objects efficiently. object sharing. What this pattern says is that if an application requires a large number of fine-grained objects, share them instead of repeated instantiation. The object you share is referred as a flyweight."
Structural,Proxy,"Provides a placeholder interface to an underlying object to control access, reduce cost, or reduce complexity. Provide a surrogate or placeholder for another object to control access to it. The Proxy pattern uses a proxy (surrogate) object “in place of” another object. The objective of a proxy object is to control the creation of and access to the real object it represents. A common use of a proxy is to defer the cost of instantiating of an object (that is expensive to create) until it is actually needed by clients."
Behavioral,Chain of Responsibility,"Delegates commands to a chain of processing objects. Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request. Chain the receiving objects and pass the request along the chain until an object handles it.  In applications there is always a client that initiates a request and an application object that handles it. What the Chain of Responsibility pattern states is – decouple the client who sends the request to the object that handles it. The solution is a list of handler objects, also known as responding objects each capable to deal with a specific nature of request. If one handler object cant handle a request, it passes it to the next object in the chain. At the end of the chain, there will be one or more generic handler objects implementing default behavior for the request."
Behavioral,Command,"Creates objects which encapsulate actions and parameters. Encapsulate a request as an object, thereby letting you parameterize clients with different requests, queue or log requests, and support undoable operations. The Command Pattern is a proven solution that addresses such recurring problems of tightly coupled invoker and receiver components in applications. This pattern states that requests should be encapsulated as objects that like any other objects can be stored and passed around the application. Requests encapsulated as objects are known as commands. In the command pattern, the invoker issues command without knowing anything about the receiver. In fact, the invoker issuing the command doesnt even know what operation will be carried out on issuing a command. Lets look at it from a programming point of view. A command object basically has a execute method and an optional undo method. The execute method executes some operation on the receiver while the undo method reverses the current operation. The implementation of the operation is done by the receiver. The invoker only sets itself up with a command object and invokes a command by calling the execute method. The invoker does not know what the execute method will do. Imagine that the invoker is a switch, When the invoker invokes a command by calling the execute method of a command object, it might turn on a light or even start a generator. What this essentially means is that the same invoker (switch) can be used to invoke commands to perform actions on different receivers (devices). We only need to create the appropriate command object and set it on the invoker. As apparent, by applying the Command Pattern we can take reusability to another level and this is made possible due to the loose coupling between the invoker and receiver and the command object that acts as the interface between them."
Behavioral,Interpreter,"Implements a specialized language. Given a language, define a representation for its grammar along with an interpreter that uses the representation to interpret sentences in the language. The best analogy of the Interpreter pattern are we, who at some times need to interpret gestures. We need to observe a gesture, and present an interpretation. Based on the culture, our interpretation may have different significance and it is our interpretation that will give the gesture different meaning. Similarly, in the programming world, applications can receive user input from a wide variety of sources, such as browsers, GUI, command line tools, and mobile phones. The input, can be expressions in different formats, such as mathematical expressions following one of the Infix, Prefix, or Postfix notations. Also, when a new type of input format is introduced, we dont want to change the client code sending the input. The solution is to use the Interpreter pattern that allows automated and flexible processing of expression provided as input by users through client code. The purpose of using the interpreter pattern is to process user input expressions and build an Abstract Syntax Tree, which we will refer as AST. This AST is an instance of the Composite pattern which I wrote about earlier. You then need a parser to parse the AST and produce the output."
Behavioral,Iterator,"Accesses the elements of an object sequentially without exposing its underlying representation. Provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation. The Iterator pattern addresses such recurring problems when dealing with aggregate objects. What this pattern says is that aggregate objects should provide a way to access its elements sequentially without exposing its internal structure. To accomplish the intent of the pattern, we need to separate the responsibility for access and traversal of the elements stored in the aggregate object and assign it to another object, which is referred as the iterator. The iterator keeps track of the elements and can perform different types of traversals sequentially based on what you want to accomplish. It is important to decouple the iterator object from the aggregate object so it can be reused for traversing other types of aggregate objects. You can design your program in such a way that the client asks the aggregate objects for its iterator, and the aggregate object returns the iterator initialized with the data structure holding the elements. The client then uses the iterator to traverse through the elements."
Behavioral,Mediator,"Allows loose coupling between classes by being the only class that has detailed knowledge of their methods. Define an object that encapsulates how a set of objects interact. Mediator promotes loose coupling by keeping objects from referring to each other explicitly, and it lets you vary their interaction independently. The Mediator pattern says that instead of allowing a set of objects to directly interact between them, define an object (mediator) that will handle the interactions. What the mediator essentially says to such set of objects is “talk with me instead of talking among yourselves”. This figure conceptually shows how objects interact without and with a mediator. It is the mediator object that encapsulates all interaction logic between objects in a system. Therefore, if an existing object is updated with new interaction rules or a new object is added to the system, it is only the mediator object that you need to update. In the absence of the mediator, you would need to update all the corresponding objects that which to interact. Through the use of the Mediator Pattern your code becomes more encapsulated, thus changes are not as extensive."
Behavioral,Memento,"Provides the ability to restore an object to its previous state. Without violating encapsulation, capture and externalize an objects internal state so that the object can be restored to this state later. When using the Memento Pattern, you have an object, called the Originator whose state (or even its partial state) needs to be saved. You then create another object, called the Memento which will hold different states of the Originator. Therefore the Memento class needs to have the same properties as the Originator in order to save the state. But if the Originator has its properties as private fields, then they wont be accessible outside the Originator. This means the Memento object cannot access the private fields? The solution to this problem is the is core to the Memento Pattern. By applying the Memento Pattern, the Originator object will be able to Create a Memento object with the current state of the Originator object. The Originator will update the Memento object whenever its state changes and it deems it necessary to save the changed state. Restore its previous state from a Memento object. By separating the logic of saving an object state from the object (Originator) itself, the Memento pattern adheres to the Single Responsibility principle, one of the SOLID design principles. The Memento itself is a POJO that remains “opaque” to other objects. It is only the Originator that can store and retrieve state information from the Memento. We have an Originator object that will create different Memento objects to hold its current state as its state changes. But how will you manage the Memento objects? This is where the Caretaker object comes into play. The purpose of the Caretaker object is the safekeeping of Memento objects. It is equally important that the Caretaker object never modifies the state of the Memento object. This modification would ripple back to the Originator object, and would be a violation of encapsulation."
Behavioral,Observer,"Is a publish/subscribe pattern which allows a number of observer objects to see an event. Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically. The Observer Pattern facilitates communication between decoupled objects. It defines relationship between objects – usually a single subject having a one-to-many relationship with multiple observers so that when the state of the subject changes, all its observers are notified accordingly. This figure illustrates what I just explained. However, GoF doesnt limit relationship between one subject with multiple registered observers. One observer can register itself with multiple subjects to receive notifications from them. Also, a subject can itself be an observer of another subject resulting in a chain of observers."
Behavioral,State,"Allows an object to alter its behavior when its internal state changes. The object will appear to change its class. Behavior of domain object (how it responds to business methods) depends on its state, and business methods may change the state forcing the object to behave differently after being invoked. The State Pattern encapsulates state of such domain object into separate classes and at runtime delegates to the object representing the current state – through what we know as polymorphism. each branch of the conditional statements in a separate class. This will enable treating the vending machine states as objects that can vary independently from its peer objects. What we are essentially doing is following the principle of “Encapsulate what varies”."
Behavioral,Strategy,"Allows one of a family of algorithms to be selected on-the-fly at run-time. Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it. define a set of related algorithm and encapsulate them in classes separated from the host class (Encryptor). Clients can choose the algorithm to use at run time. By doing so, we can easily add a new algorithm or remove an existing one without modifying the other existing algorithms or the host class."
Behavioral,Template Method,"Defines the skeleton of an algorithm as an abstract class, allowing its sub-classes to provide concrete behavior. Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithms structure. Algorithms consist of steps, and some steps can be common across algorithms. Repeating the common steps across the different algorithm-specific classes results in code duplication. In addition, if one of the common steps need modification, we need to modify it across all the implementing classes. Which opens the door to inconsistencies and defects creeping in. A more efficient approach is to put the commonality (the common steps) into an abstract base class. In the abstract class, we have a single interface method that clients call. This method makes calls in a specific order to the methods implementing the steps of the algorithm. For the common steps, we have their implementations in the abstract base class itself. The algorithm-specific subclasses extending the abstract base class will inherit those common steps. For the algorithm-specific (primitive) steps, we mark them as abstract. The algorithm-specific subclasses override the primitive steps with their own implementations. This is the Template Method Pattern. In a nutshell, this pattern defines the skeleton of an algorithm as an abstract class, allowing its subclasses to provide concrete behavior. The interface method in the abstract class that clients call is the template method – In simple terms, a method that defines an algorithm as a series of steps."
Behavioral,Visitor,"Separates an algorithm from an object structure by moving the hierarchy of methods into one object. Represent an operation to be performed on the elements of an object structure. Visitor lets you define a new operation without changing the classes of the elements on which it operates. you can separate out an algorithm present in the elements of an object structure to another object, known as a visitor. This is exactly what the GoF means in the first sentence of the Visitor patterns intent “Represent an operation to be performed on the elements of an object structure.” A practical result of this separation is the ability to add new operations to the elements of an object structure without modifying it – One way to follow the Open Closed principle. Again, this is exactly what the GoF means when it says in the second sentence of the intent – “Visitor lets you define a new operation without changing the classes of the elements on which it operates.”"
Creational,Abstract Factory,"create families of related objects that share a common theme or have dependencies among them. However, you want to ensure that the created objects are compatible and follow a consistent implementation across the family. The problem is that directly instantiating these objects in client code can result in tight coupling and difficulty in managing object creation and variations. The Abstract Factory design pattern provides a solution by introducing an abstract factory interface or class that defines methods for creating families of related objects. Each concrete subclass of the abstract factory represents a specific variant or family of objects. The client code interacts with the abstract factory and uses it to create instances of the related objects. This decouples the client code from the concrete implementations and allows for the creation of compatible and consistent object families. The Abstract Factory design pattern works because it promotes the principle of dependency inversion and abstraction. The client code depends on the abstract factory interface or class, which allows it to work with any concrete factory subclass without being tightly coupled to specific object types. By using the abstract factory, the client code can create and use objects from a specific family without needing to know the details of their creation or the specific classes involved."
Creational,Builder,"construct complex objects step by step or with varying configurations. The problem is that the traditional approach of directly constructing objects using multiple constructor parameters or setters can become cumbersome, especially when dealing with objects with numerous optional parameters or complex initialization logic. The Builder design pattern provides a solution by separating the construction of an object from its representation. It involves creating a separate builder class that handles the step-by-step construction of the object. The builder class provides methods for setting the different properties of the object and a method for retrieving the final constructed object. The client code interacts with the builder class to specify the desired configurations and create the complex object. The Builder design pattern works by simplifying the object construction process and providing a clear and readable API for constructing complex objects. By separating the construction logic into a builder class, it allows for a more fluent and intuitive way of configuring and creating objects. It also provides a consistent and controlled way of creating objects with various configurations, without the need for a large number of constructors or complex initialization code."
Creational,Factory Method,"create objects without specifying their concrete classes. This can arise when you want to decouple the client code from the specific object creation logic or when you need to support multiple object variations or families. The problem is that the client code becomes tightly coupled to the concrete classes, making it difficult to extend or change the object creation process. The Factory Method design pattern provides a solution by defining an interface or abstract class for creating objects, but delegates the actual object creation to subclasses. Instead of the client code directly instantiating the objects, it relies on the factory method defined in the interface or abstract class. Each subclass can implement the factory method to create the desired objects, encapsulating the object creation logic and allowing for flexibility and extensibility. The Factory Method design pattern works because it adheres to the ""open-closed principle"" - the client code is open for extension (by adding new subclasses) but closed for modification (as it doesn't need to change when new objects are introduced). It allows the client code to depend on abstractions rather than concrete classes, promoting loose coupling and flexibility in object creation."
Creational,Prototype,"create new objects by copying existing objects. However, creating objects from scratch can be expensive in terms of resources and time, especially when the initialization process is complex or involves costly operations. The problem is that directly creating objects using constructors or factories can lead to inefficient object creation and reduced performance. The Prototype design pattern provides a solution by introducing a prototype object that serves as a blueprint for creating new objects. Instead of creating objects from scratch, you create a clone of the prototype object and modify it as necessary. The clone operation can be shallow or deep, depending on the complexity of the object and its internal references. This approach allows you to efficiently create new objects by copying existing ones, reducing the overhead of object creation. The Prototype design pattern works by leveraging object cloning to create new objects. By using a prototype object as a blueprint, you eliminate the need for costly initialization or construction operations. Instead, you simply clone the prototype and modify the clone if required. This approach allows for efficient object creation and customization while maintaining a consistent and optimized object creation process."
Creational,Singleton,"ensure that a class has only one instance throughout the program. This can be necessary for resource management, coordination, or to maintain a central point of access for shared functionality. The problem is that multiple instances of the class can be created, leading to unnecessary resource allocation or inconsistent behavior. The Singleton design pattern provides a solution by ensuring that a class has only one instance and providing global access to that instance. It involves defining a class with a private constructor and a static method that controls the creation and access to the instance. The first time the static method is called, it creates the instance and returns it. On subsequent calls, it simply returns the existing instance. The Singleton design pattern works by enforcing the creation of a single instance of the class and providing a global point of access to that instance. By restricting the constructor to be private, it prevents external code from directly creating multiple instances. The static method ensures that only one instance is created and returned, regardless of how many times it is called."
Structural,Adapter,"integrate or use existing classes or components that have incompatible interfaces or communication protocols. The problem is that direct communication or interaction with these incompatible classes is not possible, resulting in the inability to reuse or integrate them seamlessly. The Adapter design pattern provides a solution by acting as a bridge between the incompatible interfaces or protocols. It involves creating an adapter class that wraps around the incompatible class and provides a compatible interface that other components can interact with. The adapter class translates requests or calls from the compatible interface into the corresponding calls or operations of the underlying incompatible class. The Adapter design pattern works by introducing an intermediary adapter class that acts as a layer of translation or compatibility. It allows components that require a specific interface or protocol to communicate with the incompatible class without needing to modify the existing codebase or the incompatible class itself. The adapter class encapsulates the translation logic, providing a seamless integration point for the incompatible components."
Structural,Bridge,"decouple an abstraction from its implementation. The problem is that a traditional approach with a single class hierarchy for both the abstraction and its implementation can result in a large number of class combinations and a tight coupling between the abstraction and implementation, making the codebase complex and hard to maintain. The Bridge design pattern provides a solution by separating the abstraction from its implementation using two separate class hierarchies. It involves creating an abstraction class that defines the high-level interface, and an implementation class that provides the concrete implementation details. The abstraction class contains a reference to the implementation class, allowing the abstraction to delegate specific implementation tasks to the implementation class. The Bridge design pattern works by decoupling the abstraction from its implementation, allowing them to vary independently. By encapsulating each hierarchy within its own class, the Bridge pattern promotes loose coupling and flexibility. The abstraction can select and use different implementations at runtime without modifying its code, and new abstractions and implementations can be added independently without affecting each other."
Structural,Composite,"work with hierarchical structures or collections of objects in a uniform way. The problem is that treating individual objects and groups of objects differently can lead to complex and inconsistent code. Additionally, the client code may need to perform operations on both individual objects and groups of objects without knowing their specific types. The Composite design pattern provides a solution by treating individual objects and groups of objects uniformly. It involves creating a common interface for both individual objects and groups of objects, allowing clients to interact with them in a consistent way. The individual objects and groups of objects are structured as a tree-like hierarchy, where both share a common base class or interface. The Composite design pattern works by representing individual objects and groups of objects in a unified manner through a common interface or base class. This abstraction allows clients to treat objects uniformly without needing to know their specific types. The hierarchical structure of objects enables recursive operations, where operations can be applied to both individual objects and groups of objects seamlessly."
Structural,Decorator,"add additional behavior or functionalities to an object dynamically without modifying its underlying structure or code. The problem is that traditional inheritance-based approaches can result in a rigid class hierarchy or introduce a high number of subclasses for each combination of functionalities, making the codebase complex and hard to maintain. The Decorator design pattern provides a solution by allowing you to add or modify the behavior of an object at runtime without affecting its structure. It involves creating decorator classes that wrap around the original object and provide additional functionalities by implementing the same interface as the original object. Multiple decorators can be stacked on top of each other, forming a chain of decorators. The Decorator design pattern works by extending the functionality of an object dynamically. It works by creating decorator classes that implement the same interface as the original object and contain a reference to the original object. The decorators add new functionalities by delegating the calls to the original object and adding their own behavior before or after the delegation, effectively extending or modifying the behavior of the original object."
Structural,Facade,"complex subsystem or set of classes with various dependencies needs to be simplified and presented with a unified, simplified interface. The problem is that interacting directly with the individual components of the subsystem can be cumbersome, requiring deep knowledge of the system's internal structure and dependencies. The Facade design pattern provides a solution by introducing a simplified interface or facade that hides the complexities of the underlying subsystem. It involves creating a facade class that encapsulates the interactions with the subsystem's components and provides a single entry point for clients to access the subsystem's functionalities. The facade class coordinates the actions and interactions between the subsystem's components, shielding the clients from the details of the subsystem. The Facade design pattern works by providing a high-level interface that hides the complexities of the subsystem. It encapsulates the interactions and dependencies between the subsystem's components, allowing clients to interact with the subsystem through a simplified, unified interface. By centralizing the interactions in the facade class, it becomes easier to understand, use, and maintain the subsystem, as clients can work with a consistent and simplified API."
Structural,Flyweight,"efficiently represent a large number of objects with similar properties or intrinsic data. The problem is that representing each object individually can consume significant memory and resources, especially when many objects share common state or have overlapping characteristics. The Flyweight design pattern provides a solution by separating the intrinsic and extrinsic states of objects. It involves creating a flyweight object that represents the shared state among multiple objects. The extrinsic state, which is unique to each object, is stored externally. The flyweight object is shared among multiple objects, reducing memory consumption and improving performance. The Flyweight design pattern works by promoting object sharing and reusing. By separating the intrinsic and extrinsic states, the flyweight object can be shared among multiple objects, effectively reducing the memory footprint. The extrinsic state is managed externally and passed to the flyweight objects when needed, enabling multiple objects to reuse the shared state efficiently."
Structural,Proxy,"control access to an object or provide additional functionality without modifying its underlying implementation. The problem is that direct access to the object may not be appropriate or desired due to security concerns, resource limitations, or the need for additional operations before or after accessing the object. The Proxy design pattern provides a solution by introducing a proxy object that acts as a surrogate or placeholder for the real object. The proxy object controls access to the real object and can add extra behavior or perform additional operations before or after forwarding the request to the real object. The proxy object mimics the interface of the real object, allowing clients to interact with it in a transparent manner. The Proxy design pattern works by introducing an intermediary object between the client and the real object. The proxy object provides a level of indirection, allowing it to control access to the real object and perform additional operations as necessary. Clients interact with the proxy object as if it were the real object, unaware of the underlying mechanisms and modifications made by the proxy."
Behavioral,Chain of Responsibility,"multiple objects or components need to handle a request or perform an operation sequentially. The problem is that the handling logic may vary, and the responsibility chain may change dynamically. Hard-coding the handling logic or creating tight coupling between objects can make the codebase inflexible and difficult to maintain. The Chain of Responsibility design pattern provides a solution by decoupling the sender of a request from its receivers. It involves creating a chain of handler objects, where each handler has the ability to handle the request or pass it to the next handler in the chain. The request traverses the chain until it is handled or reaches the end of the chain. The Chain of Responsibility design pattern works by separating the sender of a request from its receivers and allowing multiple objects to have a chance to handle the request. Each handler in the chain can decide whether to handle the request or pass it to the next handler. This promotes loose coupling, flexibility, and scalability, as the chain can be modified at runtime, and new handlers can be added or removed without affecting the client code."
Behavioral,Command,"decouple the sender of a request from its receiver, allowing you to parameterize clients with different requests and support undoable operations. The problem is that directly invoking operations on objects can tightly couple the sender and receiver, making it challenging to manage different requests or support undo operations. The Command design pattern provides a solution by encapsulating a request as an object, decoupling the sender from the receiver. It involves creating command objects that encapsulate a specific operation or request along with its parameters. The command objects provide an execute method that triggers the corresponding operation on the receiver object. The Command design pattern works by abstracting the sender and receiver through the command object. The sender does not need to know the details of how the request is executed or who the receiver is. It only needs to hold and execute the command object. This loose coupling enables the sender to work with different command objects, allowing for easy parameterization and dynamic composition of requests."
Behavioral,Interpreter,"interpret or evaluate structured textual expressions or rules. The problem is that implementing a grammar or rule set directly in code can be complex, inflexible, and difficult to maintain, especially when the grammar or rule set is large or subject to frequent changes. The Interpreter design pattern provides a solution by defining a language, grammar, or set of rules using a combination of classes and objects. It involves creating interpreter classes that represent the grammar rules or expressions and provide methods for their interpretation or evaluation. These interpreter classes work together to parse, evaluate, and execute the structured expressions. The Interpreter design pattern works by separating the grammar or rule set from its implementation. It allows you to define the rules or expressions using a structured representation that can be easily modified or extended. The interpreter classes interpret or evaluate these expressions based on the defined grammar, allowing you to build complex behavior by combining simple interpreters."
Behavioral,Iterator,"traverse or iterate over elements in a collection or aggregate object without exposing its underlying structure. The problem is that different collection types may have different internal structures, and client code may need to be modified when iterating over each type of collection. Additionally, you may need to iterate over the elements of a collection in different ways without modifying the collection itself. The Iterator design pattern provides a solution by decoupling the traversal or iteration logic from the underlying collection or aggregate object. It involves defining an iterator object that encapsulates the iteration behavior and provides methods for accessing the elements of the collection. The iterator object keeps track of the current position within the collection and provides methods for moving to the next element. The Iterator design pattern works by separating the iteration logic from the collection or aggregate object. The iterator provides a standardized interface for accessing elements, abstracting away the specific structure or implementation details of the collection. This allows client code to iterate over different collection types using a consistent interface without needing to modify the client code for each collection type."
Behavioral,Mediator,"set of objects need to communicate and interact with each other, but direct coupling between these objects leads to complex dependencies and tight interconnections. The problem is that managing the communication and coordination among multiple objects becomes challenging, resulting in code that is difficult to understand, maintain, and extend. The Mediator design pattern provides a solution by introducing a mediator object that encapsulates the communication and coordination logic between a set of objects. Instead of direct communication, objects communicate through the mediator, which centralizes the interaction and reduces dependencies between the objects. The mediator promotes loose coupling and simplifies the communication flow. The Mediator design pattern works by decoupling objects and centralizing their interaction through the mediator. Objects do not need to know about each other, but only about the mediator. They send requests or notifications to the mediator, which handles the communication, coordination, and routing between the objects. This reduces the complexity of managing direct object-to-object interactions and allows for more flexible and maintainable code."
Behavioral,Memento,"capture and restore an object's internal state without violating encapsulation. The problem is that directly exposing the internal state or providing public methods for state manipulation can compromise encapsulation and introduce complexity in managing object state changes. The Memento design pattern provides a solution by introducing three main components: the originator, the memento, and the caretaker. The originator represents the object whose state needs to be captured and restored. The memento is an object that stores the state of the originator. The caretaker is responsible for managing and storing the mementos. The originator creates mementos to save its state, and the caretaker stores and retrieves mementos as needed. The Memento design pattern works by encapsulating and externalizing the object's state through mementos. The originator is responsible for creating mementos and restoring its state from a memento when needed. The caretaker manages the mementos, allowing for the saving and retrieval of object states without violating encapsulation."
Behavioral,Observer,"multiple objects need to be notified and updated when the state of another object changes. The problem is that establishing direct dependencies between these objects can lead to tight coupling and code that is difficult to maintain, extend, and reuse. The Observer design pattern provides a solution by defining a one-to-many dependency between objects, where the subject (or observable) maintains a list of observers (or subscribers) and notifies them automatically when its state changes. The observers can then update themselves based on the new state of the subject. The Observer design pattern works by decoupling the subject and observers, allowing them to vary independently. The subject only needs to know about the abstract Observer interface, while observers implement this interface to receive notifications. This loose coupling enables flexible and dynamic communication between objects."
Behavioral,State,"object's behavior changes based on its internal state. The problem is that implementing conditional statements or switch-case statements to manage different behaviors can lead to complex and tightly coupled code that is difficult to maintain, extend, and understand. The State design pattern provides a solution by encapsulating each behavior in a separate state object and allowing the object to dynamically change its behavior by switching between these states. The object delegates the behavior to its current state object, decoupling the behavior from the object itself. The State design pattern works by representing each behavior as a separate state class. The object that exhibits the behavior maintains a reference to its current state object and delegates method calls to the state object. When the object's state needs to change, it switches to a different state object. This approach enables the object to have different behaviors without altering its own implementation."
Behavioral,Strategy,"dynamically change an algorithm or behavior at runtime. The problem is that hardcoding these algorithms or using conditional statements can lead to code duplication, poor maintainability, and limited flexibility. The Strategy design pattern provides a solution by encapsulating each algorithm or behavior in a separate strategy class and allowing the client to choose the appropriate strategy at runtime. The client can switch between different strategies without having to modify the core logic, promoting code reuse and flexibility. The Strategy design pattern works by defining a common interface for all strategies, allowing them to be interchangeable. The client operates on this interface, decoupling it from specific strategies. By providing different strategies that conform to the common interface, the client can dynamically select and use the appropriate strategy at runtime."
Behavioral,Template Method,"define the overall structure or algorithm of an operation, but allow certain steps or details to be implemented by subclasses or specific implementations. The problem is that directly implementing the entire algorithm in a single class can lead to code duplication, lack of flexibility, and difficulty in managing variations or customization. The Template Method design pattern provides a solution by defining the skeleton of an algorithm in a base class, while delegating the implementation of specific steps to subclasses. It involves creating an abstract base class that provides a template method defining the overall algorithm structure. The template method calls several abstract or hook methods that subclasses must implement to customize or extend the algorithm's behavior. The Template Method design pattern works by separating the high-level algorithm from the specific implementations of its steps. The base class defines the common structure and controls the overall flow of the algorithm through the template method. Subclasses can provide their own implementations for the abstract or hook methods, allowing customization and extension while adhering to the algorithm's structure."
Behavioral,Visitor,"perform operations on a group of objects that belong to different classes with different interfaces. The problem is that adding new operations or functionalities to these objects becomes challenging as it requires modifying the existing classes, violating the Open-Closed Principle. The Visitor design pattern provides a solution by separating the operations from the object structure. It introduces a Visitor class that defines separate visit methods for each type of object in the structure. Each object accepts a visitor and delegates the operation to the visitor, decoupling the objects from the specific operations performed on them. The Visitor design pattern works by leveraging double dispatch. The object structure accepts a visitor and calls the appropriate visit method based on its own type. The visitor then performs the desired operation on the object. This approach allows adding new operations or functionalities without modifying the existing object classes."
Creational,Abstract Factory,"Allows us to create a Factory for factory classes. If you are familiar with factory design pattern in java, you will notice that we have a single Factory class. This factory class returns different subclasses based on the input provided and factory class uses if-else or switch statement to achieve this. In the Abstract Factory pattern, we get rid of if-else block and have a factory class for each sub-class. Then an Abstract Factory class that will return the sub-class based on the input factory class. At first, it seems confusing but once you see the implementation, its really easy to grasp and understand the minor difference between Factory and Abstract Factory pattern. Like our factory pattern post, we will use the same superclass and sub-classes."
Creational,Builder,Creating an object step by step and a method to finally get the object instance. Builder pattern was introduced to solve some of the problems when the Object contains a lot of attributes. We can solve the issues with large number of parameters by providing a constructor with required parameters and then different setter methods to set the optional parameters. The problem with this approach is that the Object state will be inconsistent until unless all the attributes are set explicitly. Builder pattern solves the issue with large number of optional parameters and inconsistent state by providing a way to build the object step-by-step and provide a method that will actually return the final Object.
Creational,Factory Method,"The factory pattern takes out the responsibility of instantiating a object from the class to a Factory class. The factory design pattern is used when we have a superclass with multiple sub-classes and based on input, we need to return one of the sub-class. This pattern takes out the responsibility of the instantiation of a class from the client program to the factory class. Lets first learn how to implement a factory design pattern in java and then we will look into factory pattern advantages. We will see some of the factory design pattern usage in JDK."
Creational,Prototype,"Creating a new object instance from another similar instance and then modify according to our requirements. Prototype design pattern is used when the Object creation is a costly affair and requires a lot of time and resources and you have a similar object already existing. Prototype pattern provides a mechanism to copy the original object to a new object and then modify it according to our needs. Prototype design pattern uses java cloning to copy the object. It would be easy to understand prototype design pattern with an example. Suppose we have an Object that loads data from database. Now we need to modify this data in our program multiple times, so its not a good idea to create the Object using new keyword and load all the data again from database. The better approach would be to clone the existing object into a new object and then do the data manipulation. Prototype design pattern mandates that the Object which you are copying should provide the copying feature. It should not be done by any other class. However whether to use shallow or deep copy of the Object properties depends on the requirements and its a design decision."
Creational,Singleton,"The singleton pattern restricts the initialization of a class to ensure that only one instance of the class can be created. Singleton pattern restricts the instantiation of a class and ensures that only one instance of the class exists. The singleton class must provide a global access point to get the instance of the class. Singleton pattern is used for logging, drivers objects, caching, and thread pool. Private constructor to restrict instantiation of the class from other classes. Private static variable of the same class that is the only instance of the class. Public static method that returns the instance of the class, this is the global access point for the outer world to get the instance of the singleton class."
Structural,Adapter,Provides an interface between two unrelated entities so that they can work together.
Structural,Bridge,The bridge design pattern is used to decouple the interfaces from implementation and hiding the implementation details from the client program. Decouple an abstraction from its implementation so that the two can vary independently. The implementation of bridge design pattern follows the notion to prefer Composition over inheritance.
Structural,Composite,"Used when we have to implement a part-whole hierarchy. For example, a diagram made of other pieces such as circle, square, triangle, etc. When we need to create a structure in a way that the objects in the structure has to be treated the same way, we can apply composite design pattern. Lets understand it with a real life example - A diagram is a structure that consists of Objects such as Circle, Lines, Triangle etc. When we fill the drawing with color (say Red), the same color also gets applied to the Objects in the drawing. Here drawing is made up of different parts and they all have same operations. Composite Pattern consists of following objects. Base Component - Base component is the interface for all objects in the composition, client program uses base component to work with the objects in the composition. It can be an interface or an abstract class with some methods common to all the objects. Leaf - Defines the behaviour for the elements in the composition. It is the building block for the composition and implements base component. It doesnt have references to other Components. Composite - It consists of leaf elements and implements the operations in base component."
Structural,Decorator,"The decorator design pattern is used to modify the functionality of an object at runtime. used to modify the functionality of an object at runtime. At the same time other instances of the same class will not be affected by this, so individual object gets the modified behavior. We use inheritance or composition to extend the behavior of an object but this is done at compile time and its applicable to all the instances of the class. We cant add any new functionality of remove any existing behavior at runtime."
Structural,Facade,"Creating a wrapper interfaces on top of existing interfaces to help client applications. Provide a unified interface to a set of interfaces in a subsystem. Facade Pattern defines a higher-level interface that makes the subsystem easier to use. Suppose we have an application with set of interfaces to use MySql/Oracle database and to generate different types of reports, such as HTML report, PDF report etc. So we will have different set of interfaces to work with different types of database. Now a client application can use these interfaces to get the required database connection and generate reports. But when the complexity increases or the interface behavior names are confusing, client application will find it difficult to manage it. So we can apply Facade design pattern here and provide a wrapper interface on top of the existing interface to help client application."
Structural,Flyweight,"Caching and reusing object instances, used with immutable objects. Use sharing to support large numbers of fine-grained objects efficiently. Flyweight design pattern is used when we need to create a lot of Objects of a class. Since every object consumes memory space that can be crucial for low memory devices, such as mobile devices or embedded systems, flyweight design pattern can be applied to reduce the load on memory by sharing objects. The number of Objects to be created by application should be huge. The object creation is heavy on memory and it can be time consuming too. The object properties can be divided into intrinsic and extrinsic properties, extrinsic properties of an Object should be defined by the client program. To apply flyweight pattern, we need to divide Object property into intrinsic and extrinsic properties. Intrinsic properties make the Object unique whereas extrinsic properties are set by client code and used to perform different operations."
Structural,Proxy,"Provide a surrogate or placeholder for another object to control access to it. Provide a surrogate or placeholder for another object to control access to it. The definition itself is very clear and proxy design pattern is used when we want to provide controlled access of a functionality. Lets say we have a class that can run some command on the system. Now if we are using it, its fine but if we want to give this program to a client application, it can have severe issues because client program can issue command to delete some system files or change some settings that you dont want. Here a proxy class can be created to provide controlled access of the program."
Behavioral,Chain of Responsibility,Used to achieve loose coupling in software design where a request from the client is passed to a chain of objects to process them. Chain of responsibility pattern is used to achieve loose coupling in software design where a request from client is passed to a chain of objects to process them. Then the object in the chain will decide themselves who will be processing the request and whether the request is required to be sent to the next object in the chain or not.
Behavioral,Command,"Command Pattern is used to implement lose coupling in a request-response model. In command pattern, the request is send to the invoker and invoker pass it to the encapsulated command object. Command object passes the request to the appropriate method of Receiver to perform the specific action. The client program create the receiver object and then attach it to the Command. Then it creates the invoker object and attach the command object to perform an action. Now when client program executes the action, its processed based on the command and receiver object."
Behavioral,Interpreter,Defines a grammatical representation for a language and provides an interpreter to deal with this grammar.
Behavioral,Iterator,"used to provide a standard way to traverse through a group of Objects. Iterator interface provides methods for traversing through a collection. Provides a way to access the elements of an aggregate object without exposing its underlying represenation. Iterator pattern is not only about traversing through a collection, we can provide different kind of iterators based on our requirements. Iterator design pattern hides the actual implementation of traversal through the collection and client programs just use iterator methods."
Behavioral,Mediator,"used to provide a centralized communication medium between different objects in a system. Allows loose coupling by encapsulating the way disparate sets of objects interact and communicate with each other. Allows for the actions of each object set to vary independently of one another. Mediator design pattern is very helpful in an enterprise application where multiple objects are interacting with each other. If the objects interact with each other directly, the system components are tightly-coupled with each other that makes higher maintainability cost and not hard to extend. Mediator pattern focuses on provide a mediator between objects for communication and help in implementing lose-coupling between objects. Air traffic controller is a great example of mediator pattern where the airport control room works as a mediator for communication between different flights. Mediator works as a router between objects and it can have its own logic to provide way of communication. The system objects that communicate each other are called Colleagues. Usually we have an interface or abstract class that provides the contract for communication and then we have concrete implementation of mediators. For our example, we will try to implement a chat application where users can do group chat. Every user will be identified by its name and they can send and receive messages. The message sent by any user should be received by all the other users in the group."
Behavioral,Memento,The memento design pattern is used when we want to save the state of an object so that we can restore later on.
Behavioral,Observer,"useful when you are interested in the state of an object and want to get notified whenever there is any change. In observer pattern, the object that watch on the state of another object are called Observer and the object that is being watched is called Subject. Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically. Subject contains a list of observers to notify of any change in its state, so it should provide methods using which observers can register and unregister themselves. Subject also contain a method to notify all the observers of any change and either it can send the update while notifying the observer or it can provide another method to get the update. Observer should have a method to set the object to watch and another method that will be used by Subject to notify them of any updates. Java provides inbuilt platform for implementing Observer pattern through java.util.Observable class and java.util.Observer interface. However its not widely used because the implementation is really simple and most of the times we dont want to end up extending a class just for implementing Observer pattern as java doesnt provide multiple inheritance in classes. Java Message Service (JMS) uses Observer design pattern along with Mediator pattern to allow applications to subscribe and publish data to other applications. Model-View-Controller (MVC) frameworks also use Observer pattern where Model is the Subject and Views are observers that can register to get notified of any change to the model."
Behavioral,State,"State design pattern is used when an Object change its behavior based on its internal state. If we have to change the behavior of an object based on its state, we can have a state variable in the Object. Then use if-else condition block to perform different actions based on the state. State design pattern is used to provide a systematic and loosely coupled way to achieve this through Context and State implementations. State Pattern Context is the class that has a State reference to one of the concrete implementations of the State. Context forwards the request to the state object for processing."
Behavioral,Strategy,"Strategy pattern is used when we have multiple algorithm for a specific task and client decides the actual implementation to be used at runtime. Strategy pattern is also known as Policy Pattern. We define multiple algorithms and let client application pass the algorithm to be used as a parameter. One of the best example of strategy pattern is Collections.sort() method that takes Comparator parameter. Based on the different implementations of Comparator interfaces, the Objects are getting sorted in different ways."
Behavioral,Template Method,"used to create a template method stub and defer some of the steps of implementation to the subclasses. Template method defines the steps to execute an algorithm and it can provide default implementation that might be common for all or some of the subclasses. Lets understand this pattern with an example, suppose we want to provide an algorithm to build a house. The steps need to be performed to build a house are - building foundation, building pillars, building walls and windows. The important point is that the we cant change the order of execution because we cant build windows before building the foundation. So in this case we can create a template method that will use different methods to build the house. Now building the foundation for a house is same for all type of houses, whether its a wooden house or a glass house. So we can provide base implementation for this, if subclasses want to override this method, they can but mostly its common for all the types of houses. To make sure that subclasses dont override the template method, we should make it final."
Behavioral,Visitor,"Visitor pattern is used when we have to perform an operation on a group of similar kind of Objects. Visitor pattern is used when we have to perform an operation on a group of similar kind of Objects. With the help of visitor pattern, we can move the operational logic from the objects to another class. For example, think of a Shopping cart where we can add different type of items (Elements). When we click on checkout button, it calculates the total amount to be paid. Now we can have the calculation logic in item classes or we can move out this logic to another class using visitor pattern."
Creational,Abstract Factory,"The abstract factory pattern is used to provide a client with a set of related or dependant objects. The ""family"" of objects created by the factory are determined at run-time. The abstract factory pattern is a design pattern that allows for the creation of groups of related objects without the requirement of specifying the exact concrete classes that will be used. One of a number of factory classes generates the object sets. The abstract factory pattern is a Gang of Four design pattern. This is a creational pattern, as it is used to control class instantiation. The abstract factory pattern is used to provide a client with a set of related or dependant objects. The ""family"" of objects created by the factory is determined at run-time according to the selection of concrete factory class."
Creational,Builder,"The builder pattern is used to create complex objects with constituent parts that must be created in the same order or using a specific algorithm. An external class controls the construction algorithm. The builder pattern is a design pattern that allows for the step-by-step creation of complex objects using the correct sequence of actions. The construction is controlled by a director object that only needs to know the type of object it is to create. The builder pattern is a Gang of Four design pattern. This is a creational pattern as it is used to control class instantiation. The builder pattern is used to create complex objects with constituent parts that must be created in the same order or using a specific algorithm. An external class, known as the director, controls the construction algorithm."
Creational,Factory Method,"The factory pattern is used to replace class constructors, abstracting the process of object generation so that the type of the object instantiated can be determined at run-time. The factory method pattern is a design pattern that allows for the creation of objects without specifying the type of object that is to be created in code. A factory class contains a method that allows determination of the created type at run-time. The factory pattern is a Gang of Four design pattern. This is a creational pattern as it is used to control class instantiation. The factory pattern is used to replace class constructors, abstracting the process of object generation so that the type of the object instantiated can be determined at run-time."
Creational,Prototype,"The prototype pattern is used to instantiate a new object by copying all of the properties of an existing object, creating an independent clone. This practise is particularly useful when the construction of a new object is inefficient. The prototype design pattern is a design pattern that is used to instantiate a class by copying, or cloning, the properties of an existing object. The new object is an exact copy of the prototype but permits modification without altering the original. The prototype pattern is a Gang of Four design pattern. This is a creational pattern as it is used to control class instantiation and object generation. The pattern is used to instantiate a new object by copying all of the properties of an existing object, creating an independent clone. This practise is particularly useful when the construction of a brand new object, using the new operator, is inefficient. In general, when an object is cloned, the new object is either a shallow or deep copy. A shallow copy duplicates all of the object's properties. If any property contains a reference type, the reference is copied. This means that changes to the referenced object are visible in both the clone and the original object. A deep copy clones the main object and all child objects. Any properties of reference types are also cloned, giving a truly independent copy. The prototype pattern usually generates deep copies, though this is dependant upon the situation."
Creational,Singleton,"The singleton pattern ensures that only one object of a particular class is ever created. All further references to objects of the singleton class refer to the same underlying instance. The singleton pattern is a design pattern that is used to ensure that a class can only have one concurrent instance. Whenever additional objects of a singleton class are required, the previously created, single instance is provided. The singleton pattern is a Gang of Four design pattern. This is a creational pattern as it is used to control class instantiation. The pattern ensures that only one object of a particular class is ever created. All further references to objects of the singleton class refer to the same underlying instance. The singleton pattern is useful when a single, global point of access to a limited resource is required. It is more appropriate than creating a global variable as this may be copied, leading to multiple access points and the risk that the duplicates become out of step with the original."
Structural,Adapter,"The adapter pattern is used to provide a link between two otherwise incompatible types by wrapping the ""adaptee"" with a class that supports the interface required by the client. The adapter pattern is a design pattern that is used to allow two incompatible types to communicate. Where one class relies upon a specific interface that is not implemented by another class, the adapter acts as a translator between the two types. The adapter pattern is a Gang of Four design pattern. This is a structural pattern as it defines a manner for creating relationships between classes. The adapter design pattern is used to provide a link between two otherwise incompatible types by wrapping the ""adaptee"" with a class that supports the interface required by the client."
Structural,Bridge,"The bridge pattern is used to separate the abstract elements of a class from the implementation details, providing the means to replace the implementation details without modifying the abstraction. The bridge pattern is a design pattern that separates the abstract elements of a class from its technical implementation. This provides a cleaner implementation of real-world objects and allows the implementation details to be changed easily. The bridge pattern is a Gang of Four design pattern. This is a structural pattern as it defines a manner for creating relationships between classes or entities. The bridge pattern is used to separate the abstract elements of a class from the implementation details. For example, the abstract elements may be the business logic of an application. They can be created without any knowledge of the implementation details of their data access or interoperability with the operating system. The pattern provides the means to replace the implementation details without modifying the abstraction. This permits, for example, changing operating systems, databases, etc. with no impact to the business logic. When the bridge pattern is not used, you may find that implementation details are included within the same classes as abstract elements. The way in which implementation details are changed is then generally be through inheritance, with subclasses providing different implementations. This can be problematic when refined abstractions are included, also through inheritance. The number of required classes can grow exponentially as new classes that contain both business logic and implementation details are added to a system. When there is a single implementation for a single abstraction, only one class would be required. However, if you have four abstractions combined with five implementations, this can potentially require twenty classes with lots of overlap. When using the bridge design pattern, far fewer classes are necessary for all but the simplest scenarios. This is due to the pattern removing platform dependencies from the abstraction. Another benefit of the bridge pattern is that it introduces the possibility of changing the implementation details at run-time. This could permit the user to switch implementations to determine how the software interoperates with other systems. For example, allowing the user to decide whether to store information in a database, XML file or using another storage mechanism."
Structural,Composite,"The composite pattern is used to create hierarchical, recursive tree structures of related objects where any element of the structure may be accessed and utilised in a standard manner. The composite pattern is a design pattern that is used when creating hierarchical object models. The pattern defines a manner in which to design recursive tree structures of objects, where individual objects and groups can be accessed in the same manner. The composite pattern is a Gang of Four design pattern. This is a structural pattern as it defines a manner for creating relationships between classes or entities. The composite design pattern is used to create hierarchical, recursive tree structures of related objects where any element of the structure may be accessed and utilised in a standard manner. This includes individual leaf objects and those at any branch of the tree."
Structural,Decorator,"The decorator pattern is used to extend or alter the functionality of objects at run-time by wrapping them in an object of a decorator class. This provides a flexible alternative to using inheritance to modify behaviour. The decorator pattern is a design pattern that extends the functionality of individual objects by wrapping them with one or more decorator classes. These decorators can modify existing members and add new methods and properties at run-time. The decorator pattern is a Gang of Four design pattern. This is a structural pattern as it defines a manner for creating relationships between classes or entities. The decorator pattern is used to extend or alter the functionality of objects at run-time by wrapping them in an object of a decorator class. This provides a flexible alternative to using inheritance to modify behaviour. The decorator pattern is used to extend the functionality of individual objects, not classes. This means that the modifications are made at run-time rather than at design time. This allows changes to be applied to objects in response to specific conditions such as user-selected options and business rules. It also means that several objects based upon the same underlying class can be decorated in different manners. In addition, as both the class of the object being modified and the class of the decorator share a base class, multiple decorators can be applied to the same object to incrementally modify behaviour."
Structural,Facade,"The facade pattern is used to define a simplified interface to a more complex subsystem. The facade pattern is a design pattern that is used to simplify access to functionality in complex or poorly designed subsystems. The facade class provides a simple, single-class interface that hides the implementation details of the underlying code. The facade pattern is a Gang of Four design pattern. This is a structural pattern as it defines a manner for creating relationships between classes or entities. The facade design pattern is used to define a simplified interface to a more complex subsystem. The facade pattern is ideal when working with a large number of interdependent classes, or with classes that require the use of multiple methods, particularly when they are complicated to use or difficult to understand. The facade class is a ""wrapper"" that contains a set of members that are easily understood and simple to use. These members access the subsystem on behalf of the facade user, hiding the implementation details. The facade design pattern is particularly useful when wrapping subsystems that are poorly designed but cannot be refactored because the source code is unavailable or the existing interface is widely used. Sometimes you may decide to implement more than one facade to provide subsets of functionality for different purposes."
Structural,Flyweight,"The flyweight pattern is used to reduce the memory and resource usage for complex models containing many hundreds, thousands or hundreds of thousands of similar objects. The flyweight pattern is a design pattern that is used to minimise resource usage when working with very large numbers of objects. When creating many thousands of identical objects, stateless flyweights can lower the memory used to a manageable level. The flyweight pattern is a Gang of Four design pattern. This is a structural pattern as it defines a manner for creating relationships between classes. The flyweight design pattern is used to reduce the memory and resource usage for complex models containing many hundreds, thousands or even hundreds of thousands of similar objects. When you need to create a very large number of objects, each requires an amount of memory to store the object's state. Even if the storage requirements for each individual object are small, the number of objects may cause the overall memory usage to be high. Depending upon the scenario and the target environment, the memory usage may be so high that the program cannot execute. In some cases, the objects being created may include information that is often duplicated. Where this is true, the flyweight pattern can be used. When this pattern is applied, the properties of the objects that are shared and are reasonably unchanging are moved into flyweight objects. For each of the main objects that use the shared data, only a reference to the appropriate flyweight object is required. This can drastically reduce the memory used by each of the main objects. The flyweight pattern uses the concepts of intrinsic and extrinsic data. The intrinsic data is held in the properties of the flyweight objects that are shared. This information is stateless and generally remains unchanged, as any changes would be effectively replicated amongst all of the objects that reference the flyweight. Extrinsic data can be stateful as it is held outside of a flyweight object. It can be passed to methods of a flyweight when needed but should never be stored within a shared flyweight object. The flyweight design pattern often uses a variation on the factory method pattern for the generation of the shared objects. The factory receives a request for a flyweight instance. If a matching object is already in use, that particular object is returned. If not, a new flyweight is generated. Usually the full set of available flyweight objects is held within the factory in a collection that can be accessed quickly, such as a Hashtable."
Structural,Proxy,"The proxy pattern is used to provide a surrogate or placeholder object, which references an underlying object. The proxy provides the same public interface as the underlying subject class, adding a level of indirection by accepting requests from a client object and passing these to the real subject object as necessary. The proxy pattern is a design pattern that creates a surrogate, or placeholder class. Proxy instances accept requests from client objects, pass them to the underlying object and return the results. Proxies can improve efficiency and enhance functionality. The proxy pattern is a Gang of Four design pattern. This is a structural pattern as it defines a manner for creating relationships between classes or entities. The proxy design pattern is used to provide a surrogate or placeholder object, which references an underlying object. The proxy provides the same public interface as the underlying subject class. It adds a level of indirection by accepting requests from a client object and passing these to the real subject object as necessary. This can improve the efficiency of access to objects that you do not wish to access directly, perhaps because they are slow to execute or are resource-intensive, or because you wish to add extra functionality. A cache proxy improves the performance of the underlying object's members when they perform long-running tasks that return seldom-changing results. For example, the underlying object may provide a method that calculates prime numbers. When the first call to the proxy's matching method is made, the call is passed to the real object. The results from the call are stored within the proxy object and returned to the client. For subsequent calls, the cached information in the proxy can be returned without recalculating the prime numbers. A protection proxy adds a layer of security to the underlying subject object. For example, the real object may access a database and retrieve sensitive data. The protection proxy could add methods or properties that allow the client object to provide appropriate authentication before allowing the data to be returned. It could also filter the data according to the rights of the authenticated user. A remote proxy provides a local object that references a subject object in another location, generally via a network connection. The proxy performs the required actions to encode the requests for network transfer and accept the results from the remote resource before returning them to the client. A common example of a remote proxy is the local class generated by Visual Studio to provide access to a web service. Smart proxies add extra functionality to the calls to the real object's members. This functionality is often invisible to the client object. For example, counting the existing references to a resource-intensive object so that when the counter reaches zero the object's data can be removed from memory. You could also use a smart proxy to log calls to the underlying object's members. A virtual proxy provides a simplified version of a complex object. Only when the detail of the object is required is the main object actually populated, providing a form of lazy initialisation. For example, a file management utility such as Windows Explorer may use an object for each file that is visible on the screen. When obtaining the file list, the file name, size and other easy-to-retrieve information would be held in proxy objects. Only when the ""document preview"" command is requested would the real object be created and populated with the full contents of the file, as these are slower to access and require more memory."
Behavioral,Chain of Responsibility,"The chain of responsibility pattern is used to process varied requests, each of which may be dealt with by a different handler. The chain of responsibility pattern is a design pattern that defines a linked list of handlers, each of which is able to process requests. When a request is submitted to the chain, it is passed to the first handler in the list that is able to process it. The chain of responsibility pattern is a Gang of Four design pattern. This is a behavioural pattern as it defines a manner for controlling communication between classes or entities. The chain of responsibility pattern is used to process varied requests, each of which may be dealt with by a different handler. The design pattern promotes loose coupling by allowing a series of handlers to be created in a linked list or chain. The request is passed to the first handler in the chain, which will either process it or pass it on to its successor. This continues until the request is processed or the end of the chain is reached. The handler responsible for the final processing of the request need not be known beforehand. This style of processing is used by the exception handling system in C#. When an exception is thrown, the method that caused the exception is given the chance to process it, via a try-catch block. If no suitable catch is available, the exception moves up to the calling method, which may include a try-catch. This continues until the exception is handled or until there are no more possible handlers. The try-catch block itself can be thought of as using the chain of responsibility when multiple catches, each for a different type of exception, are given the option to handle an exception."
Behavioral,Command,"The command pattern is used to express a request, including the call to be made and all of its required parameters, in a command object. The command may then be executed immediately or held for later use. The command pattern is a design pattern that enables all of the information for a request to be contained within a single object. The command can then be invoked as required, often as part of a batch of queued commands with rollback capabilities. The command pattern is a Gang of Four design pattern. This is a behavioural pattern as it defines a manner for controlling communication between classes or entities. The command pattern is used to express a request, including the call to be made and all of its required parameters, in a command object. The command may then be executed immediately or held for later use. Often a queue of commands will be created that can be executed in a batch. The command object does not contain the functionality that is to be executed, only the information required to perform an action. The functionality is contained within receiver objects. This removes the direct link between the command definitions and the functionality, promoting loose coupling. Neither of these object types is responsible for determining the time of execution of the command. This is controlled using an invoker. The command pattern is useful when supporting activities that require the execution of a series of commands. The command objects can be held in a queue and processed sequentially. If each command is stored on a stack after it is executed, and if the commands are reversible, this allows the implementation of a rollback or multi-level undo facility."
Behavioral,Interpreter,"The interpreter pattern is used to define the grammar for instructions that form part of a language or notation, whilst allowing the grammar to be easily extended. The interpreter pattern is a design pattern that is useful when developing domain-specific languages or notations. The pattern allows the grammar for such a notation to be represented in an object-oriented fashion that can easily be extended. The interpreter pattern is a Gang of Four design pattern. This is a behavioural pattern as it defines a manner for controlling communication between classes or entities. The interpreter pattern is used to define the grammar for instructions that form part of a language or notation, whilst allowing the grammar to be easily extended. The interpreter pattern performs activities base upon a hierarchy of expressions. Each expression is terminal, meaning that it is a standalone structure that can be immediately evaluated, or non-terminal, meaning that it is composed of one or more expressions. The tree structure is similar to that defined by the composite design pattern, with terminal expressions being leaf objects and non-terminal expressions being composites. The tree contains the expressions to be evaluated and is usually generated by a parser. The parser itself is not a part of the interpreter pattern. The interpreter design pattern is useful for simple languages where performance is not critical. As the grammar becomes more complex, the number of different expression types, each represented by its own class, can become unwieldy and lead to unmanageable class hierarchies. This can also slow the processing of the expressions. For these reasons, the pattern is considered to be inefficient and is rarely used. However, it should not be discounted for some situations."
Behavioral,Iterator,"The iterator pattern is used to provide a standard interface for traversing a collection of items in an aggregate object without the need to understand its underlying structure. The iterator pattern is a design pattern that provides a means for the elements of an aggregate object to be accessed sequentially without knowledge of its structure. This allows traversing of lists, trees and other structures in a standard manner. The iterator pattern is a Gang of Four design pattern. This is a behavioural pattern as it defines a manner for controlling communication between classes or entities. The iterator pattern is used to provide a standard interface for traversing a collection of items in an aggregate object without the need to understand the underlying structure of that object. The interface provided is generally simplistic, providing methods to move to the next item, return to the beginning of the list, retrieve the current item and determine if the end of the list has been reached. A variation upon the iterator design pattern is used extensively within C# and the .NET framework. Iterators are included in the standard array and collection classes and can easily be added to your own classes by implementing the IEnumerable and IEnumerator interfaces. C# version 2.0 also includes the yield keyword to simplify the process of creating iterators."
Behavioral,Mediator,"The mediator pattern is used to reduce coupling between classes that communicate with each other. Instead of classes communicating directly, and thus requiring knowledge of their implementation, the classes send messages via a mediator object. The mediator pattern is a design pattern that promotes loose coupling of objects by removing the need for classes to communicate with each other directly. Instead, mediator objects are used to encapsulate and centralise the interactions between classes. The mediator pattern is a Gang of Four design pattern. This is a behavioural pattern as it defines a manner for controlling communication between classes or entities. The mediator pattern is used to reduce coupling between classes that communicate with each other. Instead of classes communicating directly, and thus requiring knowledge of their implementation, the classes send messages to a mediator object. The mediator object then transmits the messages to the other classes in a manner that they can interpret. The object initiating a message therefore requires no knowledge of the objects that will receive it. The mediator pattern promotes loose coupling of classes by removing the direct dependencies. It can also simplify communication in general when a program contains a large number of classes that interact. Each class need only know how to pass messages to its mediator, rather than to numerous colleagues. This simplified communication can improve the readability of the code. It can also increase the maintainability, as a class and its mediator may be changed without requiring modifications to other types."
Behavioral,Memento,"The memento pattern is used to capture the current state of an object and store it in such a manner that it can be restored at a later time without breaking the rules of encapsulation. The memento pattern is a design pattern that permits the current state of an object to be stored without breaking the rules of encapsulation. The originating object can be modified as required but can be restored to the saved state at any time. The memento pattern is a Gang of Four design pattern. This is a behavioural pattern as it defines a manner for controlling communication between classes or entities. The memento pattern is used to capture the current state of an object and store it in such a manner that it can be restored at a later time. Importantly, the pattern allows for the internal state of an object to be saved without breaking the rules of encapsulation. This design pattern is commonly used to provide an application with Undo functionality."
Behavioral,Observer,"The observer pattern is used to allow an object to publish changes to its state. Other objects subscribe to be immediately notified of any changes. The observer pattern is a design pattern that defines a link between objects so that when one object's state changes, all dependent objects are updated automatically. This pattern allows communication between objects in a loosely coupled manner. The observer pattern is a Gang of Four design pattern. This is a behavioural pattern as it defines a manner for controlling communication between classes or entities. The observer pattern is used to allow a single object, known as the subject, to publish changes to its state. Many other observer objects that depend upon the subject can subscribe to it so that they are immediately and automatically notified of any changes to the subject's state. The pattern gives loose coupling between the subject and its observers. The subject holds a collection of observers that are set only at run-time. Each observer may be of any class that inherits from a known base class or implements a common interface. The actual functionality of the observers and their use of the state data need not be known by the subject. A variation upon the observer pattern is seen in the .NET framework's event model. In this model, many objects may subscribe to an event and automatically be notified when the event is triggered. The observer pattern is also used widely in user interface development, particularly with data binding functionality."
Behavioral,State,"The state pattern is used to alter the behaviour of an object as its internal state changes. The pattern allows the class for an object to apparently change at run-time. The state pattern is a design pattern that allows an object to completely change its behaviour depending upon its current internal state. By substituting classes within a defined context, the state object appears to change its type at run-time. The state pattern is a Gang of Four design pattern. This is a behavioural pattern as it defines a manner for controlling communication between classes or entities. The state pattern is used to alter the behaviour of an object as its internal state changes. The pattern allows the class for an object to change at run-time without changing the interface used to access the object or losing the current state. The class change is hidden to the outside world with the use of a wrapper object, or context. The state pattern is useful when creating object-oriented state machines, where the functionality of an object changes fundamentally according to its state. By using multiple concrete classes, each inheriting from the same base class, large differences in functionality are possible without resorting to numerous ""if"" or ""switch"" statements."
Behavioral,Strategy,The strategy pattern is used to create an interchangeable family of algorithms from which the required process is chosen at run-time. The strategy pattern is a design pattern that allows a set of similar algorithms to be defined and encapsulated in their own classes. The algorithm to be used for a particular purpose may then be selected at run-time according to your requirements. The strategy pattern is a Gang of Four design pattern. This is a behavioural pattern as it defines a manner for controlling communication between classes or entities. The strategy pattern is used to create an interchangeable family of algorithms from which the required process is chosen at run-time. This allows the behaviour of a program to change dynamically according to configuration details or user preferences. It also increases flexibility by allowing new algorithms to be easily incorporated in the future.
Behavioral,Template Method,"The template method pattern is used to define the basic steps of an algorithm and allow the implementation of the individual steps to be changed. The template method pattern is a design pattern that allows a group of interchangeable, similarly structured, multi-step algorithms to be defined. Each algorithm follows the same series of actions but provides a different implementation of the steps. The template method pattern is a Gang of Four design pattern. This is a behavioural pattern as it defines a manner for controlling communication between classes or entities. The template method pattern is used to define the basic steps of an algorithm and allow the implementation of the individual steps to be changed. This is similar to the strategy design pattern. The key difference is the ability to vary parts of the algorithm rather than replacing the algorithm in its entirety. The overall structure of the basic algorithm is defined in an abstract base class. This class may include some real functionality but often just defines the order in which the overridable steps will be executed. The implementations for the steps are defined in subclasses. This use of inheritance promotes loose coupling, as the calling function need not know which algorithm is to be executed. Correct use of the pattern also reduces duplication of code."
Behavioral,Visitor,"The visitor pattern is used to separate a relatively complex set of structured data classes from the functionality that may be performed upon the data that they hold. The visitor pattern is a design pattern that separates a set of structured data from the functionality that may be performed upon it. This promotes loose coupling and enables additional operations to be added without modifying the data classes. The visitor pattern is a Gang of Four design pattern. This is a behavioural pattern as it defines a manner for controlling communication between classes or entities. The visitor pattern is used to separate a relatively complex set of structured data classes from the functionality that may be performed upon the data that they hold. This allows the creation of a data model with limited internal functionality and a set of visitors that perform operations upon the data. The pattern specifically allows each of the elements of a data structure to be visited in turn without knowing the details of the structure beforehand. The key benefit of separating the data model from the algorithms that may be applied to it is the ability to add new operations easily. The classes of the data structure are initially created with the inclusion of a method that may be called by a visitor object. This method performs a callback to the visitor, passing itself to the visitor's method as a parameter. The visitor can then perform operations upon the data object. To add a new operation, a new visitor class is created with the appropriate callback method. The data classes need no further modification. A second benefit of the design pattern is that a single visitor object is used to visit all elements of the data structure. The visitor object can maintain state between calls to individual data objects."
Creational,Factory Method,"Consider the problem of writing a framework for desktop applications. Such applications are typically organized around documents or files. Their operation usually begins with a command to create or edit a word processing document, spreadsheet, time line, or other type of document the application is intended to work with. A framework to support this type of application will include high-level support for common operations such as creating, opening, or saving documents."
Creational,Abstract Factory,"Suppose you have the task of building a user-interface framework that works on top of multiple windowing systems, such as Windows, Motif, or MacOS. It must work on each platform with the platform's native look and feel. You organize it by creating an abstract class for each type of widget (text field, pushbutton, list box, etc.) and then writing a concrete subclass of each of those classes for each supported platform. To make this robust, you need to ensure that all the widget objects created are for the desired platform."
Creational,Builder,Consider the problem of writing an email gateway program. The program receives e-mail messages that are in MIME format. It forwards them in a different format for different kinds of e-mail systems.
Creational,Prototype,"Suppose that you are writing a Computer-Assisted Design (CAD) program that allows its users to draw diagrams from a palette of symbols. The program will have a core set of built-in symbols. However, people with different and specialized interests will use the program. The core set of symbols will not be adequate for people with a specialized interest. These people will want additional symbols that are specific to their interests. Most users of this program will have a specialized interest. It must be possible to provide additional sets of symbols that users can add to the program to suit their needs."
Creational,Singleton,"Suppose you need to write a class that an applet can use to ensure that no more than one audio clip is played at a time. If an applet contains two pieces of code that independently play audio clips, then it is possible for both to be playing at the same time. When two audio clips play at the same time, the results depend on the platform. The results may range from confusing, with users hearing both audio clips together, to terrible, with the platform's sound-producing mechanism unable to cope with playing two different audio clips at once."
Creational,Object Pool,"Suppose you have been given the assignment of writing a class library to provide access to a proprietary database. Clients will send queries to the database through a network connection. The database server will receive queries through the network connection and return the results through the same connection. For a program to query the database, it must have a connection to the database. A convenient way for programmers who will use the library to manage connections is for each part of a program that needs a connection to create its own connection."
Structural,Adapter,"Suppose that you are writing a method that copies an array of objects. The method is supposed to filter out objects that do not meet certain criteria, so that the copied array may not contain all of the elements in the original array. To promote reuse, you want the method to be independent of the filtering criteria being used."
Behavioral,Iterator,"Suppose you are writing classes to browse inventory in a warehouse. There will be a user interface that allows a user to see the description, quantity on hand, location, and other information about each inventory item. The inventory browsing classes will be part of a customizable application. For this reason, they must be independent of the actual class that provides collections of inventory items."
Structural,Bridge,"Suppose you need to provide Java classes that access physical sensors for control applications. These are devices such as scales, speed-measuring devices, and location-sensing devices. What these devices have in common is that they perform a physical measurement and produce a number. One way that these devices differ is in the type of measurement that they produce. The scale produces a single number based on a measurement at a single point in time. The speed-measuring device produces a single measurement that is an average over a period of time. The location-sensing device produces a stream of measurements. The software that you are writing will need to work with sensors from multiple manufacturers called Eagle and Hawk."
Structural,Facade,"Consider the organization of classes to support the creation and sending of email messages. To use these classes, a client must know of at least these six of them, the relationships between them, and the order in which it must create instances of the classes. If every client of these classes must take on this additional complexity, it makes the email classes more difficult to reuse."
Structural,Flyweight,"Suppose that you are writing a word processor. The word processor is structured around classes such as DocumentElement, DocChar, DocumentContainer, and CharacterContext. Each DocChar object represents an individual character within a document. However, the current design allocates a separate DocChar object for each character, potentially leading to excessive memory usage, especially for larger documents. To address this issue, there's a proposal to optimize memory usage by introducing shared DocChar objects for characters that occur multiple times within the document. This revised design involves reorganizing the classes and moving extrinsic attributes like font information outside the DocChar class into a CharacterContext class."
Structural,Dynamic Linkage,"Suppose you are writing software for a new kind of smart food processor that can be fed raw ingredients and by slicing, dicing, mixing, boiling, baking, frying, and stirring is able to produce cooked, ready-to-eat food. On a mechanical level, the new food processor is a very sophisticated piece of equipment. However, a crucial part of the food processor is a selection of programs to prepare different kinds of foods. A program that can turn flour, water, yeast, and other ingredients into different kinds of bread is very different from a program that can stir-fry shrimp to exactly the right texture. The food processor will be required to run a great variety of programs that allow it to produce a great variety of foods. Because of the large variety of programs that will be required, it is not possible to build them all into the food processor. Instead, the food processor will load its programs from a CD-ROM or similar medium."
Structural,Virtual Proxy,"Suppose you are part of a team that has written a large Java applet for a company that operates a chain of home improvement warehouses. The applet allows people to buy everything that the warehouses sell through a Web page. In addition to offering a catalog, it includes a variety of assistants to allow customers to decide just what they need. There are more assistants, but they are not the point of this discussion. The point is that the applet is very large. Due to its size, it takes an unacceptably long amount of time for a browser to download the applet over a modem connection."
Structural,Decorator,"Suppose you are responsible for maintaining the software of a security system that controls physical access to a building. Its basic architecture is that a card reader or other data entry device captures some identifying information and passes the information to the object that controls a door. If the object that controls the door is satisfied with the information, it unlocks the door. Suppose that you need to integrate this access control mechanism with a surveillance system. A surveillance system typically has more cameras connected to it than it has TV monitors. Most of the TV monitors cycle through the images from different cameras. They show a picture from each camera for a few seconds and then move on to the next camera for which the monitor is responsible. There are rules about how the surveillance system is supposed to be set up to ensure its effectiveness."
Structural,Composite,"Suppose that you are writing a document formatting program. It formats characters into lines of text organized into columns that are organized into pages. However, a document may contain other elements. Columns and pages can contain frames that can contain columns. Columns, frames, and lines of text can contain images."
Behavioral,Command,Suppose you want to design a word processing program so that it can undo and redo commands. A way to accomplish this is to materialize each command as an object with do and undo methods.
Behavioral,Mediator,Suppose you have to implement a dialog box in order to specify information to reserve a banquet room in a hotel. The purpose of the dialog is to provide information to reserve a banquet room in a hotel. The requirements of the dialog give rise to a number of dependencies among the dialog's objects.
Behavioral,Observer,"Suppose that you are working for a company that manufactures smoke detectors, motion sensors, and other security devices. To take advantage of new market opportunities, your company plans to introduce a new line of devices. These devices will be able to send a signal to a security card that can be installed in most computers. The hope is that companies that make security-monitoring systems will integrate these devices and cards with their systems. To make it easy to integrate the cards with monitoring systems, you have been given the task of creating an easy-to-use API. The API must allow your future customers to easily integrate their programs with it so their programs will receive notifications from the security card. It must work without forcing the customers to alter the architecture of their existing software. All that the API may assume about the customer's software is that at least one, and possibly more than one, object will have a method that should be called when a notification is received from a security device."
Behavioral,State,Suppose that you are writing a dialog for editing parameters of a program. The dialog will have buttons for specifying the disposition of changes you have made. The dialog will have an OK button that saves the parameter values in the dialog to both a file and the program's working values. The dialog will have a Save button that saves the parametervalues only to a file. The dialog will have an Apply button that saves the parameter values only to the program's working values. The dialog will have a Revert button that restores the dialog values from the file.
Behavioral,Null Object,"You have been given the task of writing classes to encapsulate an enterprise's business rules. Because these classes will be used in a variety of environments, there is a requirement that these objects be able to route warning messages to a dialog box, a log file, other destinations, or nowhere at all."
Behavioral,Strategy,Suppose you have to write a program that displays calendars. One of the requirements for the program is that it be able to display sets of holidays celebrated by different nations and different religious groups. The user must be able to specify which sets of holidays to display. You would like to satisfy the requirement by putting the logic for each set of holidays in a separate class. This will give you a set of small classes to which you could easily add more classes. You want classes that use these holiday classes to be unaware of any specific set of holidays.
Behavioral,Template Method,"Suppose that you have the task of writing a reusable class for logging users into an application or applet. In addition to being reusable and easy to use, the tasks of the class will be to: Prompt the user for a user ID and password. Authenticate the user ID and password. The result of the authentication operation should be an object. If the authentication operation produces some information needed later as proof of authentication, then the object produced by the authentication operation should encapsulate the information. While the authentication operation is in progress, the user should see a changing and possibly animated display that tells the user that authentication is in progress and all is well. Notify the rest of the application or applet that login is complete and make the object produced by the authentication operation available to the rest of the application. Every application or applet will have to provide its own logic for these tasks."
Behavioral,Visitor,"Suppose you have the assignment of adding new features to a word processor related to its ability to produce a table of contents. From the viewpoint of a user, there will be a dialog that allows the user to specify information that guides the building of a table of contents. The word processor allows a style name to be associated with each paragraph. The dialog will allow the user to specify which paragraph styles correspond to headings that should appear in the table of contents. The word processor uses information specified in the dialog to build an internal table that contains all the information it needs to build a multilevel table of contents. In the rest of this description, the table is referred to as the internal ToC table. The information in each row of the table will include a level number that can correspond to chapter, section, and subsection or any other hierarchical organization the user wants to represent. The rows of the table will also include a paragraph style and other information for formatting the table of contents. If a paragraph style appears in the table, it means paragraphs with that style are headings whose first line will appear in that level of a table of contents. In addition to adding the dialog and internal ToC table to the word processor, you will have to add these table-of-contents-related features: Generate and insert a table of contents for a single file document into that document. Reorganize a single file document into a multifile document, based on a heading level in the internal ToC table."